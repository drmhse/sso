use crate::auth::device_flow::DeviceFlowService;
use crate::auth::jwt::JwtService;
use crate::auth::sso::{OAuthClient, Provider};
use crate::db::models::{DeviceCode, Identity, User};
use crate::error::{AppError, Result};
use axum::{
    extract::{Path, Query, State},
    response::{Html, IntoResponse, Redirect, Response},
    Json,
};
use chrono::Utc;
use oauth2::{CsrfToken, PkceCodeChallenge, PkceCodeVerifier};
use serde::{Deserialize, Serialize};
use sqlx::SqlitePool;
use std::sync::Arc;
use tokio::sync::{mpsc, oneshot};
use uuid::Uuid;

// --- Define Message for DB Writer Task ---
// The message now carries all the data, pre-generated by the handler.
pub enum DbRequest {
    CreateDeviceCode {
        id: String,
        device_code: String,
        user_code: String,
        client_id: String,
        org_slug: String,
        service_slug: String,
        responder: oneshot::Sender<Result<DeviceCode>>,
    },
}

#[derive(Clone)]
pub struct AppState {
    pub pool: SqlitePool,
    pub oauth_client: Arc<OAuthClient>,
    pub jwt_service: Arc<JwtService>,
    pub base_url: String,
    pub db_tx: mpsc::Sender<DbRequest>, // Sender for the DB writer task
    pub encryption: Option<Arc<crate::encryption::EncryptionService>>,
}
// --- End DB Task Definitions ---

// SSO Authorization Request
#[derive(Debug, Deserialize)]
pub struct AuthRequest {
    pub org: String,
    pub service: String,
    pub redirect_uri: Option<String>,
}

// Admin Auth Request
#[derive(Debug, Deserialize)]
pub struct AdminAuthRequest {
    pub org_slug: Option<String>,
}

// SSO Callback Query Parameters
#[derive(Debug, Deserialize)]
pub struct CallbackQuery {
    pub code: String,
    pub state: Option<String>,
}

// Device Code Request
#[derive(Debug, Deserialize)]
pub struct DeviceCodeRequest {
    pub client_id: String,
    pub org: String,
    pub service: String,
}

// Device Code Response
#[derive(Debug, Serialize)]
pub struct DeviceCodeResponse {
    pub device_code: String,
    pub user_code: String,
    pub verification_uri: String,
    pub expires_in: i64,
    pub interval: i64,
}

// Device Verify Request
#[derive(Debug, Deserialize)]
pub struct DeviceVerifyRequest {
    pub user_code: String,
}

// Token Request
#[derive(Debug, Deserialize)]
pub struct TokenRequest {
    pub client_id: String,
    pub device_code: String,
    pub grant_type: String,
}

// Token Response
#[derive(Debug, Serialize)]
pub struct TokenResponse {
    pub access_token: String,
    pub token_type: String,
    pub expires_in: i64,
}

/// SSO: Initiate OAuth flow
pub async fn auth_provider(
    State(state): State<AppState>,
    Path(provider_str): Path<String>,
    Query(params): Query<AuthRequest>,
) -> Result<Response> {
    let provider = Provider::from_str(&provider_str)?;

    // Get service to fetch configured scopes and validate redirect_uri
    let service = sqlx::query_as::<_, crate::db::models::Service>(
        "SELECT s.* FROM services s JOIN organizations o ON s.org_id = o.id
         WHERE o.slug = ? AND s.slug = ?",
    )
    .bind(&params.org)
    .bind(&params.service)
    .fetch_optional(&state.pool)
    .await?;

    let service = service.ok_or_else(|| AppError::NotFound("Service not found".to_string()))?;

    // Validate redirect_uri against allowed URIs
    if let Some(redirect_uri) = &params.redirect_uri {
        validate_redirect_uri(redirect_uri, &service)?;
    }

    let scopes = get_provider_scopes(&service, provider);

    // Check if organization has custom OAuth credentials for this provider
    let org_id = sqlx::query_scalar::<_, String>("SELECT id FROM organizations WHERE slug = ?")
        .bind(&params.org)
        .fetch_one(&state.pool)
        .await?;

    let provider_str = provider.as_str();
    let org_credentials = sqlx::query!(
        "SELECT client_id, client_secret_encrypted, encryption_key_id 
         FROM organization_oauth_credentials 
         WHERE org_id = ? AND provider = ?",
        org_id,
        provider_str
    )
    .fetch_optional(&state.pool)
    .await?;

    let (auth_url, csrf_token, pkce_verifier) = if let Some(creds) = org_credentials {
        // Use organization's custom OAuth credentials
        let encryption = crate::encryption::EncryptionService::new()
            .map_err(|e| AppError::InternalServerError(format!("Encryption unavailable: {}", e)))?;

        let client_secret = encryption
            .decrypt(&creds.client_secret_encrypted)
            .map_err(|e| {
                AppError::InternalServerError(format!("Failed to decrypt secret: {}", e))
            })?;

        let config = crate::config::Config::from_env()
            .map_err(|e| AppError::InternalServerError(e.to_string()))?;

        let custom_client =
            create_custom_oauth_client(&config, provider, &creds.client_id, &client_secret)?;
        get_authorization_url_for_client(&custom_client, provider, scopes)
    } else {
        // Fall back to platform's default OAuth credentials
        state
            .oauth_client
            .get_authorization_url_with_pkce(provider, scopes)
    };

    // Store OAuth state
    let expires_at = Utc::now() + chrono::Duration::minutes(10);
    let pkce_value = if provider == Provider::Microsoft && !pkce_verifier.is_empty() {
        Some(pkce_verifier)
    } else {
        None
    };

    sqlx::query(
        "INSERT INTO oauth_states (state, pkce_verifier, service_id, redirect_uri, org_slug, service_slug, is_admin_flow, user_id_for_linking, created_at, expires_at)
         VALUES (?, ?, ?, ?, ?, ?, 0, NULL, datetime('now'), ?)",
    )
    .bind(csrf_token.secret())
    .bind(pkce_value)
    .bind(&service.id)
    .bind(&params.redirect_uri)
    .bind(&params.org)
    .bind(&params.service)
    .bind(&expires_at)
    .execute(&state.pool)
    .await?;

    Ok(Redirect::to(&auth_url).into_response())
}

fn get_provider_scopes(service: &crate::db::models::Service, provider: Provider) -> Vec<String> {
    let scopes_json = match provider {
        Provider::Github => &service.github_scopes,
        Provider::Microsoft => &service.microsoft_scopes,
        Provider::Google => &service.google_scopes,
    };

    scopes_json
        .as_ref()
        .and_then(|s| serde_json::from_str(s).ok())
        .unwrap_or_else(default_scopes)
}

fn default_scopes() -> Vec<String> {
    vec!["user:email".to_string()]
}

/// SSO: Handle OAuth callback
pub async fn auth_callback(
    State(state): State<AppState>,
    Path(provider_str): Path<String>,
    Query(callback): Query<CallbackQuery>,
) -> Result<Response> {
    let provider = Provider::from_str(&provider_str)?;

    // Get OAuth state (includes PKCE verifier, redirect_uri, org/service context)
    let oauth_state = if let Some(ref state_param) = callback.state {
        sqlx::query_as::<_, crate::db::models::OAuthState>(
            "SELECT * FROM oauth_states WHERE state = ?",
        )
        .bind(state_param)
        .fetch_optional(&state.pool)
        .await?
    } else {
        None
    };

    // Exchange code with PKCE verifier to get full token details
    let pkce_verifier = oauth_state
        .as_ref()
        .and_then(|s| s.pkce_verifier.as_deref());
    let token_details = state
        .oauth_client
        .exchange_code_with_details(provider, &callback.code, pkce_verifier)
        .await?;

    // Get user info from provider
    let user_info = state
        .oauth_client
        .get_user_info(provider, &token_details.access_token)
        .await?;

    // Check if this is a linking flow (user_id_for_linking is set)
    if let Some(ref oauth_ctx) = oauth_state {
        if let Some(ref linking_user_id) = oauth_ctx.user_id_for_linking {
            // This is a linking flow - link the new provider to the existing user

            // Security check: Ensure the provider account is not already linked to a different user
            let existing_identity = sqlx::query_as::<_, crate::db::models::Identity>(
                "SELECT * FROM identities WHERE provider = ? AND provider_user_id = ?",
            )
            .bind(provider.as_str())
            .bind(&user_info.provider_user_id)
            .fetch_optional(&state.pool)
            .await?;

            if let Some(existing) = existing_identity {
                if existing.user_id != *linking_user_id {
                    // Clean up OAuth state
                    if let Some(ref state_param) = callback.state {
                        let _ = sqlx::query("DELETE FROM oauth_states WHERE state = ?")
                            .bind(state_param)
                            .execute(&state.pool)
                            .await;
                    }

                    return Err(AppError::BadRequest(
                        "This social account is already linked to a different user".to_string(),
                    ));
                }
                // Already linked to the same user, just update tokens
            }

            // Create or update identity for the linking user
            upsert_identity_with_details(
                &state.pool,
                state.encryption.as_ref(),
                linking_user_id,
                provider,
                &user_info.provider_user_id,
                &token_details.access_token,
                token_details.refresh_token.as_deref(),
                token_details.expires_at,
                &token_details.scopes,
            )
            .await?;

            // Clean up OAuth state
            if let Some(ref state_param) = callback.state {
                let _ = sqlx::query("DELETE FROM oauth_states WHERE state = ?")
                    .bind(state_param)
                    .execute(&state.pool)
                    .await;
            }

            // Redirect to frontend callback URL with success status
            let redirect_url = format!("{}/settings/connections?status=success", state.base_url);
            return Ok(Redirect::to(&redirect_url).into_response());
        }
    }

    // Normal login flow - find or create user
    let user = find_or_create_user(&state.pool, &user_info.email).await?;

    // Update identity with full token details
    upsert_identity_with_details(
        &state.pool,
        state.encryption.as_ref(),
        &user.id,
        provider,
        &user_info.provider_user_id,
        &token_details.access_token,
        token_details.refresh_token.as_deref(),
        token_details.expires_at,
        &token_details.scopes,
    )
    .await?;

    // Clean up OAuth state
    if let Some(ref state_param) = callback.state {
        let _ = sqlx::query("DELETE FROM oauth_states WHERE state = ?")
            .bind(state_param)
            .execute(&state.pool)
            .await;
    }

    // Handle device flow completion
    if let Some(ref oauth_ctx) = oauth_state {
        if oauth_ctx.redirect_uri.is_none()
            && (oauth_ctx.org_slug.is_some() || oauth_ctx.service_slug.is_some())
        {
            // This is a device flow callback - find and update the device code
            if let (Some(org_slug), Some(service_slug)) =
                (&oauth_ctx.org_slug, &oauth_ctx.service_slug)
            {
                // Find pending device code for this org/service
                let device_code = sqlx::query_as::<_, DeviceCode>(
                    "SELECT * FROM device_codes
                     WHERE org_slug = ? AND service_slug = ? AND status = 'pending'
                     ORDER BY created_at DESC LIMIT 1",
                )
                .bind(org_slug)
                .bind(service_slug)
                .fetch_optional(&state.pool)
                .await?;

                if let Some(dc) = device_code {
                    // Authorize the device code
                    sqlx::query!(
                        "UPDATE device_codes SET user_id = ?, status = 'authorized' WHERE id = ?",
                        user.id,
                        dc.id
                    )
                    .execute(&state.pool)
                    .await?;
                }
            }

            // Show device authorization success page
            let html = r#"
                <!DOCTYPE html>
                <html>
                <head><title>Device Authorized</title></head>
                <body>
                    <h1>Device Successfully Authorized</h1>
                    <p>Your device can now complete the authentication process.</p>
                    <p>You can close this window.</p>
                </body>
                </html>
            "#;
            return Ok(Html(html).into_response());
        }
    }

    // If redirect_uri provided, issue JWT and redirect
    if let Some(ref oauth_ctx) = oauth_state {
        if let Some(ref redirect_uri) = oauth_ctx.redirect_uri {
            // Get service and subscription info for JWT
            let (service_slug, plan_name, features) =
                if let (Some(org), Some(svc)) = (&oauth_ctx.org_slug, &oauth_ctx.service_slug) {
                    // Get service
                    let service = sqlx::query_as::<_, crate::db::models::Service>(
                        "SELECT s.* FROM services s JOIN organizations o ON s.org_id = o.id
                     WHERE o.slug = ? AND s.slug = ?",
                    )
                    .bind(org)
                    .bind(svc)
                    .fetch_optional(&state.pool)
                    .await?;

                    if let Some(service) = service {
                        // Validate redirect_uri again before redirecting
                        validate_redirect_uri(redirect_uri, &service)?;
                        // Get subscription if exists
                        let subscription = sqlx::query!(
                            r#"
                        SELECT p.name as plan_name, p.features
                        FROM subscriptions sub
                        JOIN plans p ON sub.plan_id = p.id
                        WHERE sub.user_id = ? AND sub.service_id = ? AND sub.status = 'active'
                        "#,
                            user.id,
                            service.id
                        )
                        .fetch_optional(&state.pool)
                        .await?;

                        let plan = subscription
                            .as_ref()
                            .map(|s| s.plan_name.clone())
                            .unwrap_or_else(|| "free".to_string());
                        let feats = subscription
                            .as_ref()
                            .and_then(|s| s.features.as_ref())
                            .and_then(|f| serde_json::from_str::<Vec<String>>(f).ok());

                        (Some(svc.clone()), Some(plan), feats)
                    } else {
                        (None, None, None)
                    }
                } else {
                    (None, None, None)
                };

            // Create JWT
            let jwt = state.jwt_service.create_token(
                &user.id,
                &user.email,
                user.is_platform_owner,
                oauth_ctx.org_slug.as_deref(),
                service_slug.as_deref(),
                plan_name.as_deref(),
                features,
            )?;

            // Store session
            let session_id = uuid::Uuid::new_v4().to_string();
            let token_hash = JwtService::hash_token(&jwt);
            let expires_at = Utc::now() + chrono::Duration::hours(24);

            sqlx::query!(
                "INSERT INTO sessions (id, user_id, token_hash, expires_at) VALUES (?, ?, ?, ?)",
                session_id,
                user.id,
                token_hash,
                expires_at
            )
            .execute(&state.pool)
            .await?;

            // Redirect with JWT as query parameter
            let redirect_url = format!("{}?token={}", redirect_uri, jwt);
            return Ok(Redirect::to(&redirect_url).into_response());
        }
    }

    // No redirect_uri - show HTML success page
    let html = format!(
        r#"
        <!DOCTYPE html>
        <html>
        <head><title>Authentication Successful</title></head>
        <body>
            <h1>Authentication Successful</h1>
            <p>User: {}</p>
            <p>Provider: {}</p>
        </body>
        </html>
        "#,
        user_info.email,
        provider.as_str()
    );

    Ok(Html(html).into_response())
}

/// Device Flow: Create device code
pub async fn device_code(
    State(state): State<AppState>,
    Json(req): Json<DeviceCodeRequest>,
) -> Result<Json<DeviceCodeResponse>> {
    // Read operations can still happen directly as they don't block writers in WAL mode.
    let service_count: i64 = sqlx::query_scalar(
        r#"
        SELECT COUNT(*) FROM services s
        JOIN organizations o ON s.org_id = o.id
        WHERE s.client_id = ? AND o.slug = ? AND s.slug = ?
        "#,
    )
    .bind(&req.client_id)
    .bind(&req.org)
    .bind(&req.service)
    .fetch_one(&state.pool)
    .await?;

    if service_count == 0 {
        return Err(AppError::BadRequest(
            "Invalid client credentials".to_string(),
        ));
    }

    // --- Perform CPU-bound work here, in the parallel handler ---
    let id = Uuid::new_v4().to_string();
    let device_code = DeviceFlowService::generate_device_code();
    let user_code = DeviceFlowService::generate_user_code();
    // --- End CPU-bound work ---

    let (tx, rx) = oneshot::channel();
    let db_request = DbRequest::CreateDeviceCode {
        id,
        device_code: device_code.clone(),
        user_code: user_code.clone(),
        client_id: req.client_id,
        org_slug: req.org,
        service_slug: req.service,
        responder: tx,
    };

    state.db_tx.send(db_request).await.map_err(|e| {
        AppError::InternalServerError(format!("Failed to send to DB writer: {}", e))
    })?;

    let _ = rx.await.map_err(|e| {
        AppError::InternalServerError(format!("Failed to receive from DB writer: {}", e))
    })??;

    Ok(Json(DeviceCodeResponse {
        device_code,
        user_code,
        verification_uri: format!("{}/activate", state.base_url),
        expires_in: 900, // 15 minutes
        interval: 5,     // Poll every 5 seconds
    }))
}

/// Device Flow: Activation page
pub async fn activate_page() -> Html<&'static str> {
    Html(
        r#"
        <!DOCTYPE html>
        <html>
        <head>
            <title>Device Activation</title>
            <style>
                body { font-family: Arial, sans-serif; max-width: 500px; margin: 50px auto; }
                input { padding: 10px; font-size: 18px; width: 100%; margin: 10px 0; }
                button { padding: 10px 20px; font-size: 16px; background: #007bff; color: white; border: none; cursor: pointer; }
            </style>
        </head>
        <body>
            <h1>Device Activation</h1>
            <p>Enter the code displayed on your device:</p>
            <form method="POST" action="/auth/device/verify">
                <input type="text" name="user_code" placeholder="XXXX-XXXX" required pattern="[A-Z0-9]{4}-[A-Z0-9]{4}" />
                <button type="submit">Activate</button>
            </form>
        </body>
        </html>
        "#,
    )
}

/// Device Flow: Verify user code (after SSO login)
pub async fn device_verify(
    State(state): State<AppState>,
    Json(req): Json<DeviceVerifyRequest>,
) -> Result<Response> {
    // Find device code
    let device_code = DeviceFlowService::find_by_user_code(&state.pool, &req.user_code)
        .await?
        .ok_or_else(|| AppError::BadRequest("Invalid user code".to_string()))?;

    // Check if expired
    if DeviceFlowService::is_expired(&device_code) {
        return Err(AppError::DeviceCodeExpired);
    }

    // Check if already authorized
    if DeviceFlowService::is_authorized(&device_code) {
        return Ok(Html(
            r#"
            <!DOCTYPE html>
            <html>
            <head><title>Already Authorized</title></head>
            <body>
                <h1>Device Already Authorized</h1>
                <p>Your device has been authorized. You can close this window.</p>
            </body>
            </html>
        "#,
        )
        .into_response());
    }

    // Generate OAuth state for device flow
    let expires_at = Utc::now() + chrono::Duration::minutes(10);
    let state_token = uuid::Uuid::new_v4().to_string();

    // Store device flow state
    let org_slug = device_code.org_slug.to_string();
    let service_slug = device_code.service_slug.to_string();
    let is_admin_flow = false;
    sqlx::query(
        "INSERT INTO oauth_states (state, pkce_verifier, service_id, redirect_uri, org_slug, service_slug, is_admin_flow, user_id_for_linking, created_at, expires_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, NULL, datetime('now'), ?)",
    )
    .bind(&state_token)
    .bind(Option::<String>::None) // No PKCE for device flow
    .bind(Option::<String>::None) // No specific service
    .bind(Option::<String>::None) // No redirect URI
    .bind(&org_slug)
    .bind(&service_slug)
    .bind(is_admin_flow)
    .bind(&expires_at)
    .execute(&state.pool)
    .await?;

    // Redirect to SSO provider selection page
    let html = format!(
        r#"
        <!DOCTYPE html>
        <html>
        <head>
            <title>Device Authorization</title>
            <style>
                body {{ font-family: Arial, sans-serif; max-width: 500px; margin: 50px auto; padding: 20px; }}
                .provider-button {{ display: block; width: 100%; padding: 15px; margin: 10px 0;
                                 background: #007bff; color: white; text-decoration: none;
                                 text-align: center; border-radius: 5px; }}
                .provider-button:hover {{ background: #0056b3; }}
            </style>
        </head>
        <body>
            <h1>Authorize Your Device</h1>
            <p>Choose a provider to sign in and authorize:</p>
            <a href="/auth/github?org={}&service={}&state={}" class="provider-button">
                Sign in with GitHub
            </a>
            <a href="/auth/google?org={}&service={}&state={}" class="provider-button">
                Sign in with Google
            </a>
            <a href="/auth/microsoft?org={}&service={}&state={}" class="provider-button">
                Sign in with Microsoft
            </a>
        </body>
        </html>
    "#,
        device_code.org_slug,
        device_code.service_slug,
        state_token,
        device_code.org_slug,
        device_code.service_slug,
        state_token,
        device_code.org_slug,
        device_code.service_slug,
        state_token
    );

    Ok(Html(html).into_response())
}

/// Device Flow: Exchange device code for token
pub async fn token_exchange(
    State(state): State<AppState>,
    Json(req): Json<TokenRequest>,
) -> Result<Json<TokenResponse>> {
    // Validate grant type
    if req.grant_type != "urn:ietf:params:oauth:grant-type:device_code" {
        return Err(AppError::BadRequest("Invalid grant type".to_string()));
    }

    // Validate and get device code
    let device_code = DeviceFlowService::validate_for_token_exchange(
        &state.pool,
        &req.device_code,
        &req.client_id,
    )
    .await?;

    let user_id = device_code
        .user_id
        .ok_or_else(|| AppError::Unauthorized("Not authorized".to_string()))?;

    // Get user info
    let user = sqlx::query_as::<_, User>(
        "SELECT id, email, is_platform_owner, created_at FROM users WHERE id = ?",
    )
    .bind(&user_id)
    .fetch_one(&state.pool)
    .await?;

    // Get service and plan info
    let result = sqlx::query!(
        r#"
        SELECT
            s.slug as service_slug,
            o.slug as org_slug,
            p.name as plan_name,
            p.features as features
        FROM services s
        JOIN organizations o ON s.org_id = o.id
        LEFT JOIN subscriptions sub ON sub.service_id = s.id AND sub.user_id = ?
        LEFT JOIN plans p ON sub.plan_id = p.id
        WHERE o.slug = ? AND s.slug = ?
        "#,
        user_id,
        device_code.org_slug,
        device_code.service_slug
    )
    .fetch_one(&state.pool)
    .await?;

    let plan_name = result.plan_name.unwrap_or_else(|| "free".to_string());
    let features: Vec<String> = result
        .features
        .as_ref()
        .and_then(|f| serde_json::from_str(f).ok())
        .unwrap_or_default();

    // Generate JWT
    let token = state.jwt_service.create_token(
        &user.id,
        &user.email,
        user.is_platform_owner,
        Some(&result.org_slug),
        Some(&result.service_slug),
        Some(&plan_name),
        Some(features),
    )?;

    // Store session
    let session_id = Uuid::new_v4().to_string();
    let token_hash = JwtService::hash_token(&token);
    let expires_at = Utc::now() + chrono::Duration::hours(24);

    sqlx::query!(
        r#"
        INSERT INTO sessions (id, user_id, token_hash, expires_at)
        VALUES (?, ?, ?, ?)
        "#,
        session_id,
        user_id,
        token_hash,
        expires_at
    )
    .execute(&state.pool)
    .await?;

    Ok(Json(TokenResponse {
        access_token: token,
        token_type: "Bearer".to_string(),
        expires_in: 86400, // 24 hours
    }))
}

// Helper functions

async fn find_or_create_user(pool: &SqlitePool, email: &str) -> Result<User> {
    // Try to find existing user
    if let Some(user) = sqlx::query_as::<_, User>("SELECT * FROM users WHERE email = ?")
        .bind(email)
        .fetch_optional(pool)
        .await?
    {
        return Ok(user);
    }

    // Create new user
    let id = Uuid::new_v4().to_string();
    let user = sqlx::query_as::<_, User>(
        r#"
        INSERT INTO users (id, email, is_platform_owner, created_at)
        VALUES (?, ?, 0, ?)
        RETURNING *
        "#,
    )
    .bind(&id)
    .bind(email)
    .bind(Utc::now())
    .fetch_one(pool)
    .await?;

    Ok(user)
}

async fn upsert_identity_with_details(
    pool: &SqlitePool,
    encryption: Option<&Arc<crate::encryption::EncryptionService>>,
    user_id: &str,
    provider: Provider,
    provider_user_id: &str,
    access_token: &str,
    refresh_token: Option<&str>,
    expires_at: Option<chrono::DateTime<Utc>>,
    scopes: &[String],
) -> Result<Identity> {
    let id = Uuid::new_v4().to_string();
    let provider_str = provider.as_str();
    let scopes_json =
        serde_json::to_string(scopes).map_err(|e| AppError::InternalServerError(e.to_string()))?;

    // Encrypt tokens if encryption service is available
    let identity = if let Some(enc) = encryption {
        let access_token_encrypted = enc
            .encrypt(access_token)
            .map_err(|e| AppError::InternalServerError(format!("Failed to encrypt access token: {}", e)))?;

        let refresh_token_encrypted = refresh_token
            .map(|rt| enc.encrypt(rt))
            .transpose()
            .map_err(|e| AppError::InternalServerError(format!("Failed to encrypt refresh token: {}", e)))?;

        sqlx::query_as::<_, Identity>(
            r#"
            INSERT INTO identities (id, user_id, provider, provider_user_id, access_token, refresh_token, access_token_encrypted, refresh_token_encrypted, encryption_key_id, expires_at, scopes)
            VALUES (?, ?, ?, ?, NULL, NULL, ?, ?, ?, ?, ?)
            ON CONFLICT(user_id, provider)
            DO UPDATE SET
                access_token = NULL,
                refresh_token = NULL,
                access_token_encrypted = excluded.access_token_encrypted,
                refresh_token_encrypted = COALESCE(excluded.refresh_token_encrypted, refresh_token_encrypted),
                encryption_key_id = excluded.encryption_key_id,
                expires_at = excluded.expires_at,
                provider_user_id = excluded.provider_user_id,
                scopes = excluded.scopes,
                last_refreshed_at = datetime('now')
            RETURNING *
            "#,
        )
        .bind(&id)
        .bind(user_id)
        .bind(provider_str)
        .bind(provider_user_id)
        .bind(&access_token_encrypted)
        .bind(&refresh_token_encrypted)
        .bind(enc.key_id())
        .bind(expires_at)
        .bind(scopes_json)
        .fetch_one(pool)
        .await?
    } else {
        // No encryption - store in plaintext (fallback for backward compatibility)
        sqlx::query_as::<_, Identity>(
            r#"
            INSERT INTO identities (id, user_id, provider, provider_user_id, access_token, refresh_token, expires_at, scopes)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT(user_id, provider)
            DO UPDATE SET
                access_token = excluded.access_token,
                refresh_token = COALESCE(excluded.refresh_token, refresh_token),
                expires_at = excluded.expires_at,
                provider_user_id = excluded.provider_user_id,
                scopes = excluded.scopes,
                last_refreshed_at = datetime('now')
            RETURNING *
            "#,
        )
        .bind(&id)
        .bind(user_id)
        .bind(provider_str)
        .bind(provider_user_id)
        .bind(access_token)
        .bind(refresh_token)
        .bind(expires_at)
        .bind(scopes_json)
        .fetch_one(pool)
        .await?
    };

    Ok(identity)
}

/// Logout: Invalidate JWT session
pub async fn logout(
    State(state): State<AppState>,
    headers: axum::http::HeaderMap,
) -> Result<impl IntoResponse> {
    // Extract token from Authorization header
    let token = headers
        .get("Authorization")
        .and_then(|header| header.to_str().ok())
        .and_then(|header| header.strip_prefix("Bearer "))
        .ok_or_else(|| {
            AppError::Unauthorized("Missing or invalid Authorization header".to_string())
        })?;

    // Hash token
    let token_hash = JwtService::hash_token(token);

    // Delete session
    sqlx::query!("DELETE FROM sessions WHERE token_hash = ?", token_hash)
        .execute(&state.pool)
        .await
        .map_err(AppError::Database)?;

    Ok(axum::http::StatusCode::NO_CONTENT)
}

/// Admin Auth: Initiate OAuth flow for platform/org admin login
pub async fn auth_admin_provider(
    State(state): State<AppState>,
    Path(provider_str): Path<String>,
    Query(params): Query<AdminAuthRequest>,
) -> Result<Response> {
    let provider = Provider::from_str(&provider_str)?;

    // Build admin OAuth client dynamically using PLATFORM_* credentials
    let config = crate::config::Config::from_env()
        .map_err(|e| AppError::InternalServerError(e.to_string()))?;

    let admin_oauth_client = create_admin_oauth_client(&config, provider)?;

    // Use default admin scopes
    let scopes = vec!["user:email".to_string()];

    // Generate authorization URL with PKCE (for Microsoft)
    let (auth_url, csrf_token, pkce_verifier) =
        get_admin_authorization_url(&admin_oauth_client, provider, scopes);

    // Store OAuth state with is_admin_flow = true
    let expires_at = Utc::now() + chrono::Duration::minutes(10);
    let pkce_value = if provider == Provider::Microsoft && !pkce_verifier.is_empty() {
        Some(pkce_verifier)
    } else {
        None
    };

    let is_admin_flow = true;
    sqlx::query(
        "INSERT INTO oauth_states (state, pkce_verifier, service_id, redirect_uri, org_slug, service_slug, is_admin_flow, user_id_for_linking, created_at, expires_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, NULL, datetime('now'), ?)",
    )
    .bind(csrf_token.secret())
    .bind(pkce_value)
    .bind(Option::<String>::None)
    .bind(Option::<String>::None)
    .bind(&params.org_slug)
    .bind(Option::<String>::None)
    .bind(is_admin_flow)
    .bind(&expires_at)
    .execute(&state.pool)
    .await?;

    Ok(Redirect::to(&auth_url).into_response())
}

/// Admin Auth: Handle OAuth callback for admin login
pub async fn auth_admin_callback(
    State(state): State<AppState>,
    Path(provider_str): Path<String>,
    Query(callback): Query<CallbackQuery>,
) -> Result<Response> {
    let provider = Provider::from_str(&provider_str)?;

    // Get OAuth state and verify it's an admin flow
    let oauth_state = if let Some(ref state_param) = callback.state {
        sqlx::query_as::<_, crate::db::models::OAuthState>(
            "SELECT * FROM oauth_states WHERE state = ?",
        )
        .bind(state_param)
        .fetch_optional(&state.pool)
        .await?
    } else {
        None
    };

    let oauth_state =
        oauth_state.ok_or_else(|| AppError::BadRequest("Invalid state parameter".to_string()))?;

    if !oauth_state.is_admin_flow {
        return Err(AppError::BadRequest("Not an admin flow".to_string()));
    }

    // Build admin OAuth client with PLATFORM_* credentials
    let config = crate::config::Config::from_env()
        .map_err(|e| AppError::InternalServerError(e.to_string()))?;

    let admin_oauth_client = create_admin_oauth_client(&config, provider)?;

    // Exchange code with PKCE verifier
    let pkce_verifier = oauth_state.pkce_verifier.as_deref();
    let token_details =
        exchange_admin_code(&admin_oauth_client, provider, &callback.code, pkce_verifier).await?;

    // Get user info from provider
    let user_info = state
        .oauth_client
        .get_user_info(provider, &token_details.access_token)
        .await?;

    // Find or create user
    let user = find_or_create_user(&state.pool, &user_info.email).await?;

    // Update identity
    upsert_identity_with_details(
        &state.pool,
        state.encryption.as_ref(),
        &user.id,
        provider,
        &user_info.provider_user_id,
        &token_details.access_token,
        token_details.refresh_token.as_deref(),
        token_details.expires_at,
        &token_details.scopes,
    )
    .await?;

    // Clean up OAuth state
    if let Some(ref state_param) = callback.state {
        let _ = sqlx::query("DELETE FROM oauth_states WHERE state = ?")
            .bind(state_param)
            .execute(&state.pool)
            .await;
    }

    // Decision logic for JWT type
    let jwt = if user.is_platform_owner {
        // Create Platform JWT (no org or service claims)
        state
            .jwt_service
            .create_token(&user.id, &user.email, true, None, None, None, None)?
    } else if let Some(org_slug) = &oauth_state.org_slug {
        // Check if user is a member of the requested organization
        let membership = sqlx::query_as::<_, crate::db::models::Membership>(
            "SELECT m.* FROM memberships m
             JOIN organizations o ON m.org_id = o.id
             WHERE o.slug = ? AND m.user_id = ?",
        )
        .bind(org_slug)
        .bind(&user.id)
        .fetch_optional(&state.pool)
        .await?;

        if let Some(_membership) = membership {
            // Create Org Management JWT (org claim present, service claim null)
            state.jwt_service.create_token(
                &user.id,
                &user.email,
                false,
                Some(org_slug),
                None,
                None,
                None,
            )?
        } else {
            // User is not a member - issue basic JWT so they can access signup page
            state.jwt_service.create_token(
                &user.id,
                &user.email,
                false,
                None,
                None,
                None,
                None,
            )?
        }
    } else {
        // No org_slug provided and not platform owner - issue basic JWT for first-time users
        state.jwt_service.create_token(
            &user.id,
            &user.email,
            false,
            None,
            None,
            None,
            None,
        )?
    };

    // Store session
    let session_id = Uuid::new_v4().to_string();
    let token_hash = JwtService::hash_token(&jwt);
    let expires_at = Utc::now() + chrono::Duration::hours(24);

    sqlx::query!(
        "INSERT INTO sessions (id, user_id, token_hash, expires_at) VALUES (?, ?, ?, ?)",
        session_id,
        user.id,
        token_hash,
        expires_at
    )
    .execute(&state.pool)
    .await?;

    // Redirect to platform admin frontend with JWT
    let redirect_url = format!("{}?token={}", config.platform_admin_redirect_uri, jwt);
    Ok(Redirect::to(&redirect_url).into_response())
}

// Helper functions for admin OAuth

/// Unified OAuth client builder to reduce code duplication.
/// Creates an OAuth2 BasicClient for any provider with the given credentials and callback URI.
fn build_oauth_client(
    provider: Provider,
    client_id: String,
    client_secret: String,
    callback_uri: String,
) -> Result<oauth2::basic::BasicClient> {
    use oauth2::{basic::BasicClient, AuthUrl, ClientId, ClientSecret, RedirectUrl, TokenUrl};

    let (auth_url, token_url) = match provider {
        Provider::Github => (
            "https://github.com/login/oauth/authorize",
            "https://github.com/login/oauth/access_token",
        ),
        Provider::Google => (
            "https://accounts.google.com/o/oauth2/v2/auth",
            "https://oauth2.googleapis.com/token",
        ),
        Provider::Microsoft => (
            "https://login.microsoftonline.com/common/oauth2/v2.0/authorize",
            "https://login.microsoftonline.com/common/oauth2/v2.0/token",
        ),
    };

    Ok(BasicClient::new(
        ClientId::new(client_id),
        Some(ClientSecret::new(client_secret)),
        AuthUrl::new(auth_url.to_string()).map_err(|e| AppError::OAuth(e.to_string()))?,
        Some(TokenUrl::new(token_url.to_string()).map_err(|e| AppError::OAuth(e.to_string()))?),
    )
    .set_redirect_uri(RedirectUrl::new(callback_uri).map_err(|e| AppError::OAuth(e.to_string()))?))
}

fn create_admin_oauth_client(
    config: &crate::config::Config,
    provider: Provider,
) -> Result<oauth2::basic::BasicClient> {
    let (client_id, client_secret) = match provider {
        Provider::Github => (
            config.platform_github_client_id.clone(),
            config.platform_github_client_secret.clone(),
        ),
        Provider::Google => (
            config.platform_google_client_id.clone(),
            config.platform_google_client_secret.clone(),
        ),
        Provider::Microsoft => (
            config.platform_microsoft_client_id.clone(),
            config.platform_microsoft_client_secret.clone(),
        ),
    };

    let callback_uri = format!("{}/auth/admin/{}/callback", config.base_url, provider.as_str());

    build_oauth_client(provider, client_id, client_secret, callback_uri)
}

fn get_admin_authorization_url(
    client: &oauth2::basic::BasicClient,
    provider: Provider,
    scopes: Vec<String>,
) -> (String, CsrfToken, String) {
    use oauth2::Scope;

    let scopes_oauth: Vec<Scope> = scopes.into_iter().map(Scope::new).collect();

    // Generate PKCE challenge (only for Microsoft)
    let (pkce_challenge, pkce_verifier) = if provider == Provider::Microsoft {
        let (challenge, verifier) = PkceCodeChallenge::new_random_sha256();
        (Some(challenge), Some(verifier))
    } else {
        (None, None)
    };

    let mut auth_request = client
        .authorize_url(CsrfToken::new_random)
        .add_scopes(scopes_oauth);

    if let Some(challenge) = pkce_challenge {
        auth_request = auth_request.set_pkce_challenge(challenge);
    }

    let (auth_url, csrf_token) = auth_request.url();

    let verifier_secret = pkce_verifier
        .map(|v| v.secret().clone())
        .unwrap_or_default();

    (auth_url.to_string(), csrf_token, verifier_secret)
}

async fn exchange_admin_code(
    client: &oauth2::basic::BasicClient,
    _provider: Provider,
    code: &str,
    pkce_verifier: Option<&str>,
) -> Result<crate::auth::sso::TokenDetails> {
    use oauth2::{AuthorizationCode, TokenResponse};

    let mut token_request = client.exchange_code(AuthorizationCode::new(code.to_string()));

    if let Some(verifier) = pkce_verifier {
        token_request =
            token_request.set_pkce_verifier(PkceCodeVerifier::new(verifier.to_string()));
    }

    let token = token_request
        .request_async(oauth2::reqwest::async_http_client)
        .await
        .map_err(|e| AppError::OAuth(format!("Token exchange failed: {}", e)))?;

    let expires_at = token
        .expires_in()
        .map(|duration| Utc::now() + chrono::Duration::seconds(duration.as_secs() as i64));

    let scopes = token
        .scopes()
        .map(|scopes| scopes.iter().map(|s| s.to_string()).collect::<Vec<_>>())
        .unwrap_or_default();

    Ok(crate::auth::sso::TokenDetails {
        access_token: token.access_token().secret().clone(),
        refresh_token: token.refresh_token().map(|rt| rt.secret().clone()),
        expires_at,
        scopes,
    })
}

// Helper functions for BYOO (Bring Your Own OAuth)

fn validate_redirect_uri(redirect_uri: &str, service: &crate::db::models::Service) -> Result<()> {
    if let Some(ref allowed_uris_json) = service.redirect_uris {
        let allowed_uris: Vec<String> = serde_json::from_str(allowed_uris_json).map_err(|e| {
            AppError::InternalServerError(format!("Invalid redirect_uris JSON: {}", e))
        })?;

        if !allowed_uris.contains(&redirect_uri.to_string()) {
            return Err(AppError::BadRequest(format!(
                "redirect_uri '{}' is not registered for this service",
                redirect_uri
            )));
        }
    }
    // If no redirect_uris configured, allow any (backward compatibility)
    Ok(())
}

fn create_custom_oauth_client(
    config: &crate::config::Config,
    provider: Provider,
    client_id: &str,
    client_secret: &str,
) -> Result<oauth2::basic::BasicClient> {
    let callback_uri = format!("{}/auth/{}/callback", config.base_url, provider.as_str());
    build_oauth_client(
        provider,
        client_id.to_string(),
        client_secret.to_string(),
        callback_uri,
    )
}

fn get_authorization_url_for_client(
    client: &oauth2::basic::BasicClient,
    provider: Provider,
    scopes: Vec<String>,
) -> (String, CsrfToken, String) {
    use oauth2::Scope;

    let scopes_oauth: Vec<Scope> = scopes.into_iter().map(Scope::new).collect();

    // Generate PKCE challenge (only for Microsoft)
    let (pkce_challenge, pkce_verifier) = if provider == Provider::Microsoft {
        let (challenge, verifier) = PkceCodeChallenge::new_random_sha256();
        (Some(challenge), Some(verifier))
    } else {
        (None, None)
    };

    let mut auth_request = client
        .authorize_url(CsrfToken::new_random)
        .add_scopes(scopes_oauth);

    if let Some(challenge) = pkce_challenge {
        auth_request = auth_request.set_pkce_challenge(challenge);
    }

    let (auth_url, csrf_token) = auth_request.url();

    let verifier_secret = pkce_verifier
        .map(|v| v.secret().clone())
        .unwrap_or_default();

    (auth_url.to_string(), csrf_token, verifier_secret)
}
