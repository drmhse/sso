use crate::auth::device_flow::DeviceFlowService;
use crate::auth::jwt::JwtService;
use crate::auth::sso::{OAuthClient, Provider};
use crate::constants::{DEVICE_CODE_EXPIRE_MINUTES, JWT_EXPIRE_HOURS, OAUTH_STATE_EXPIRE_MINUTES};
use crate::db::models::{DeviceCode, Identity, User};
use crate::error::{AppError, Result};
use axum::{
    extract::{Path, Query, State},
    response::{Html, IntoResponse, Redirect, Response},
    Json,
};
use chrono::Utc;
use oauth2::{CsrfToken, PkceCodeChallenge, PkceCodeVerifier};
use serde::{Deserialize, Serialize};
use sqlx::SqlitePool;
use std::sync::Arc;
use tokio::sync::{mpsc, oneshot};
use oauth2::url;
use uuid::Uuid;

// Custom HTTP client wrapper for better OAuth error logging and GitHub error detection
async fn oauth_http_client(
    request: oauth2::HttpRequest,
) -> std::result::Result<oauth2::HttpResponse, oauth2::reqwest::Error<reqwest::Error>> {
    tracing::debug!("OAuth request: {:?} {}", request.method, request.url);

    let mut result = oauth2::reqwest::async_http_client(request).await;

    // GitHub returns errors with 200 OK status but with JSON containing "error" field
    // We need to detect this and convert it to a proper error response
    if let Ok(ref response) = result {
        tracing::debug!("OAuth response: status={}, body_len={}",
            response.status_code, response.body.len());

        let body_str = String::from_utf8_lossy(&response.body);

        if response.status_code.is_success() {
            tracing::debug!("OAuth success response body: {}", body_str);

            // Check if the response body contains an error (GitHub's quirk)
            if let Ok(json_value) = serde_json::from_str::<serde_json::Value>(&body_str) {
                if let Some(error) = json_value.get("error").and_then(|e| e.as_str()) {
                    let error_description = json_value.get("error_description")
                        .and_then(|d| d.as_str())
                        .unwrap_or(error);

                    tracing::error!("OAuth provider returned error in success response: error={}, description={}",
                        error, error_description);

                    // Convert to a proper error by returning a 400 status
                    result = Ok(oauth2::HttpResponse {
                        status_code: oauth2::http::StatusCode::BAD_REQUEST,
                        headers: response.headers.clone(),
                        body: response.body.clone(),
                    });
                }
            }
        } else {
            tracing::error!("OAuth error response: status={}, body={}",
                response.status_code, body_str);
        }
    } else if let Err(e) = &result {
        tracing::error!("OAuth HTTP client error: {:?}", e);
    }

    result
}

// --- Define Message for DB Writer Task ---
// The message now carries all the data, pre-generated by the handler.
pub enum DbRequest {
    CreateDeviceCode {
        id: String,
        device_code: String,
        user_code: String,
        client_id: String,
        org_slug: String,
        service_slug: String,
        responder: oneshot::Sender<Result<DeviceCode>>,
    },
}

#[derive(Clone)]
pub struct AppState {
    pub pool: SqlitePool,
    pub oauth_client: Arc<OAuthClient>,
    pub jwt_service: Arc<JwtService>,
    pub base_url: String,
    pub db_tx: mpsc::Sender<DbRequest>, // Sender for the DB writer task
    pub encryption: Option<Arc<crate::encryption::EncryptionService>>,
}
// --- End DB Task Definitions ---

// SSO Authorization Request
#[derive(Debug, Deserialize)]
pub struct AuthRequest {
    pub org: String,
    pub service: String,
    pub redirect_uri: Option<String>,
    pub user_code: Option<String>,
}

// Admin Auth Request
#[derive(Debug, Deserialize)]
pub struct AdminAuthRequest {
    pub org_slug: Option<String>,
    pub user_code: Option<String>,
}

// SSO Callback Query Parameters
#[derive(Debug, Deserialize)]
pub struct CallbackQuery {
    pub code: String,
    pub state: Option<String>,
}

// Device Code Request
#[derive(Debug, Deserialize)]
pub struct DeviceCodeRequest {
    pub client_id: String,
    pub org: String,
    pub service: String,
}

// Device Code Response
#[derive(Debug, Serialize)]
pub struct DeviceCodeResponse {
    pub device_code: String,
    pub user_code: String,
    pub verification_uri: String,
    pub expires_in: i64,
    pub interval: i64,
}

// Device Verify Request
#[derive(Debug, Deserialize)]
pub struct DeviceVerifyRequest {
    pub user_code: String,
}

// Device Verify Response
#[derive(Debug, Serialize)]
pub struct DeviceVerifyResponse {
    pub org_slug: String,
    pub service_slug: String,
    pub available_providers: Vec<String>,
}

// Token Request
#[derive(Debug, Deserialize)]
pub struct TokenRequest {
    pub client_id: String,
    pub device_code: String,
    pub grant_type: String,
}

// Token Response
#[derive(Debug, Serialize)]
pub struct TokenResponse {
    pub access_token: String,
    pub token_type: String,
    pub expires_in: i64,
}

/// SSO: Initiate OAuth flow
pub async fn auth_provider(
    State(state): State<AppState>,
    Path(provider_str): Path<String>,
    Query(params): Query<AuthRequest>,
) -> Result<Response> {
    let provider = Provider::from_str(&provider_str)?;

    // Get service to fetch configured scopes and validate redirect_uri
    let service = sqlx::query_as::<_, crate::db::models::Service>(
        "SELECT s.* FROM services s JOIN organizations o ON s.org_id = o.id
         WHERE o.slug = ? AND s.slug = ?",
    )
    .bind(&params.org)
    .bind(&params.service)
    .fetch_optional(&state.pool)
    .await?;

    let service = service.ok_or_else(|| AppError::NotFound("Service not found".to_string()))?;

    // Validate redirect_uri against allowed URIs
    if let Some(redirect_uri) = &params.redirect_uri {
        validate_redirect_uri(redirect_uri, &service)?;
    }

    let scopes = get_provider_scopes(&service, provider);

    // Check if organization has custom OAuth credentials for this provider
    let org_id = sqlx::query_scalar::<_, String>("SELECT id FROM organizations WHERE slug = ?")
        .bind(&params.org)
        .fetch_one(&state.pool)
        .await?;

    let provider_str = provider.as_str();
    let org_credentials = sqlx::query!(
        "SELECT client_id, client_secret_encrypted, encryption_key_id 
         FROM organization_oauth_credentials 
         WHERE org_id = ? AND provider = ?",
        org_id,
        provider_str
    )
    .fetch_optional(&state.pool)
    .await?;

    let (auth_url, csrf_token, pkce_verifier) = if let Some(creds) = org_credentials {
        // Use organization's custom OAuth credentials
        let encryption = crate::encryption::EncryptionService::new()
            .map_err(|e| AppError::InternalServerError(format!("Encryption unavailable: {}", e)))?;

        let client_secret = encryption
            .decrypt(&creds.client_secret_encrypted)
            .map_err(|e| {
                AppError::InternalServerError(format!("Failed to decrypt secret: {}", e))
            })?;

        let config = crate::config::Config::from_env()
            .map_err(|e| AppError::InternalServerError(e.to_string()))?;

        let custom_client =
            create_custom_oauth_client(&config, provider, &creds.client_id, &client_secret)?;
        get_authorization_url_for_client(&custom_client, provider, scopes)
    } else {
        // Fall back to platform's default OAuth credentials
        state
            .oauth_client
            .get_authorization_url_with_pkce(provider, scopes)
    };

    // Store OAuth state
    let expires_at = Utc::now() + chrono::Duration::minutes(OAUTH_STATE_EXPIRE_MINUTES);
    let pkce_value = if provider == Provider::Microsoft && !pkce_verifier.is_empty() {
        Some(pkce_verifier)
    } else {
        None
    };

    sqlx::query(
        "INSERT INTO oauth_states (state, pkce_verifier, service_id, redirect_uri, org_slug, service_slug, is_admin_flow, user_id_for_linking, device_user_code, created_at, expires_at)
         VALUES (?, ?, ?, ?, ?, ?, 0, NULL, ?, datetime('now'), ?)",
    )
    .bind(csrf_token.secret())
    .bind(pkce_value)
    .bind(&service.id)
    .bind(&params.redirect_uri)
    .bind(&params.org)
    .bind(&params.service)
    .bind(&params.user_code)
    .bind(expires_at)
    .execute(&state.pool)
    .await?;

    Ok(Redirect::to(&auth_url).into_response())
}

pub fn get_provider_scopes(service: &crate::db::models::Service, provider: Provider) -> Vec<String> {
    let scopes_json = match provider {
        Provider::Github => &service.github_scopes,
        Provider::Microsoft => &service.microsoft_scopes,
        Provider::Google => &service.google_scopes,
    };

    scopes_json
        .as_ref()
        .and_then(|s| serde_json::from_str(s).ok())
        .unwrap_or_else(|| default_scopes_for_provider(provider))
}

fn default_scopes_for_provider(provider: Provider) -> Vec<String> {
    match provider {
        Provider::Github => vec!["user:email".to_string()],
        Provider::Microsoft => vec!["User.Read".to_string(), "email".to_string(), "openid".to_string(), "profile".to_string()],
        Provider::Google => vec!["openid".to_string(), "email".to_string(), "profile".to_string()],
    }
}

/// SSO: Handle OAuth callback
pub async fn auth_callback(
    State(state): State<AppState>,
    Path(provider_str): Path<String>,
    Query(callback): Query<CallbackQuery>,
) -> Result<Response> {
    // Wrap the main logic to catch errors and handle them appropriately
    match auth_callback_impl(state, provider_str, callback).await {
        Ok(response) => Ok(response),
        Err(e) => {
            // Log the error
            tracing::error!("OAuth callback error: {}", e);

            // Return a simple HTML error page
            let error_message = match &e {
                AppError::OAuth(msg) => msg.clone(),
                AppError::BadRequest(msg) => msg.clone(),
                AppError::Unauthorized(msg) => msg.clone(),
                _ => "Authentication failed".to_string(),
            };

            // Simple HTML escaping for error message
            let escaped_error = error_message
                .replace('&', "&amp;")
                .replace('<', "&lt;")
                .replace('>', "&gt;")
                .replace('"', "&quot;")
                .replace('\'', "&#x27;");

            let html = format!(
                r#"
                <!DOCTYPE html>
                <html>
                <head><title>Authentication Failed</title></head>
                <body>
                    <h1>Authentication Failed</h1>
                    <p>Error: {}</p>
                    <p>Please try again or contact support.</p>
                </body>
                </html>
                "#,
                escaped_error
            );

            Ok(Html(html).into_response())
        }
    }
}

/// Internal implementation of OAuth callback that can return errors
async fn auth_callback_impl(
    state: AppState,
    provider_str: String,
    callback: CallbackQuery,
) -> Result<Response> {
    let provider = Provider::from_str(&provider_str)?;

    // Get OAuth state (includes PKCE verifier, redirect_uri, org/service context)
    let oauth_state = if let Some(ref state_param) = callback.state {
        sqlx::query_as::<_, crate::db::models::OAuthState>(
            "SELECT * FROM oauth_states WHERE state = ?",
        )
        .bind(state_param)
        .fetch_optional(&state.pool)
        .await?
    } else {
        None
    };

    // Clean up OAuth state immediately to prevent replay attacks
    // We extract all needed info first, then delete the state before token exchange
    if let Some(ref state_param) = callback.state {
        let _ = sqlx::query("DELETE FROM oauth_states WHERE state = ?")
            .bind(state_param)
            .execute(&state.pool)
            .await;
    }

    // Exchange code with PKCE verifier to get full token details
    // Check if we should use organization's BYOO credentials
    let pkce_verifier = oauth_state
        .as_ref()
        .and_then(|s| s.pkce_verifier.as_deref());

    // Determine issuing context (org_id and service_id) for proper identity isolation
    let (token_details, issuing_org_id, issuing_service_id) = if let Some(ref oauth_ctx) = oauth_state {
        // Check if this is a service flow (has service_id)
        if let Some(ref service_id) = oauth_ctx.service_id {
            // Service flow - get org_id from service and use service credentials
            let service = sqlx::query_as::<_, crate::db::models::Service>(
                "SELECT * FROM services WHERE id = ?"
            )
            .bind(service_id)
            .fetch_one(&state.pool)
            .await?;

            let org_id = service.org_id.clone();

            // Check for BYOO credentials for this organization
            let provider_str = provider.as_str();
            let org_credentials = sqlx::query!(
                "SELECT client_id, client_secret_encrypted, encryption_key_id
                 FROM organization_oauth_credentials
                 WHERE org_id = ? AND provider = ?",
                org_id,
                provider_str
            )
            .fetch_optional(&state.pool)
            .await?;

            let details = if let Some(creds) = org_credentials {
                // Use organization's custom OAuth credentials for token exchange
                let encryption = crate::encryption::EncryptionService::new()
                    .map_err(|e| AppError::InternalServerError(format!("Encryption unavailable: {}", e)))?;

                let client_secret = encryption
                    .decrypt(&creds.client_secret_encrypted)
                    .map_err(|e| {
                        AppError::InternalServerError(format!("Failed to decrypt secret: {}", e))
                    })?;

                let config = crate::config::Config::from_env()
                    .map_err(|e| AppError::InternalServerError(e.to_string()))?;

                let custom_client =
                    create_custom_oauth_client(&config, provider, &creds.client_id, &client_secret)?;

                exchange_custom_code(&custom_client, provider, &callback.code, pkce_verifier).await?
            } else {
                // Fall back to platform credentials for this service
                state
                    .oauth_client
                    .exchange_code_with_details(provider, &callback.code, pkce_verifier)
                    .await?
            };

            (details, Some(org_id), Some(service_id.clone()))
        } else if let Some(ref org_slug) = oauth_ctx.org_slug {
            // Legacy org-based flow (no service_id) - use org credentials but no service isolation
            let org_id = sqlx::query_scalar::<_, String>("SELECT id FROM organizations WHERE slug = ?")
                .bind(org_slug)
                .fetch_one(&state.pool)
                .await?;

            let provider_str = provider.as_str();
            let org_credentials = sqlx::query!(
                "SELECT client_id, client_secret_encrypted, encryption_key_id
                 FROM organization_oauth_credentials
                 WHERE org_id = ? AND provider = ?",
                org_id,
                provider_str
            )
            .fetch_optional(&state.pool)
            .await?;

            let details = if let Some(creds) = org_credentials {
                // Use organization's custom OAuth credentials for token exchange
                let encryption = crate::encryption::EncryptionService::new()
                    .map_err(|e| AppError::InternalServerError(format!("Encryption unavailable: {}", e)))?;

                let client_secret = encryption
                    .decrypt(&creds.client_secret_encrypted)
                    .map_err(|e| {
                        AppError::InternalServerError(format!("Failed to decrypt secret: {}", e))
                    })?;

                let config = crate::config::Config::from_env()
                    .map_err(|e| AppError::InternalServerError(e.to_string()))?;

                let custom_client =
                    create_custom_oauth_client(&config, provider, &creds.client_id, &client_secret)?;

                exchange_custom_code(&custom_client, provider, &callback.code, pkce_verifier).await?
            } else {
                // Fall back to platform credentials
                state
                    .oauth_client
                    .exchange_code_with_details(provider, &callback.code, pkce_verifier)
                    .await?
            };

            (details, Some(org_id), None)
        } else {
            // No service or org context - platform credentials
            let details = state
                .oauth_client
                .exchange_code_with_details(provider, &callback.code, pkce_verifier)
                .await?;
            (details, None, None)
        }
    } else {
        // No oauth state - platform credentials
        let details = state
            .oauth_client
            .exchange_code_with_details(provider, &callback.code, pkce_verifier)
            .await?;
        (details, None, None)
    };

    // Get user info from provider (standalone, not using OAuth client)
    let user_info = get_provider_user_info(provider, &token_details.access_token).await?;

    // Check if this is a linking flow (user_id_for_linking is set)
    if let Some(ref oauth_ctx) = oauth_state {
        if let Some(ref linking_user_id) = oauth_ctx.user_id_for_linking {
            // This is a linking flow - link the new provider to the existing user

            // Security check: Ensure the provider account is not already linked to a different user
            let existing_identity = sqlx::query_as::<_, crate::db::models::Identity>(
                "SELECT * FROM identities WHERE provider = ? AND provider_user_id = ?",
            )
            .bind(provider.as_str())
            .bind(&user_info.provider_user_id)
            .fetch_optional(&state.pool)
            .await?;

            if let Some(existing) = existing_identity {
                if existing.user_id != *linking_user_id {
                    return Err(AppError::BadRequest(
                        "This social account is already linked to a different user".to_string(),
                    ));
                }
                // Already linked to the same user, just update tokens
            }

            // Create or update identity for the linking user
            upsert_identity_with_details(
                &state.pool,
                state.encryption.as_ref(),
                linking_user_id,
                provider,
                &user_info.provider_user_id,
                &token_details.access_token,
                token_details.refresh_token.as_deref(),
                token_details.expires_at,
                &token_details.scopes,
                issuing_org_id.as_deref(),
                issuing_service_id.as_deref(),
            )
            .await?;

            // Redirect to frontend callback URL
            // redirect_uri already contains query params: ?status=success&provider=X&action=link
            let redirect_url = oauth_ctx.redirect_uri.as_ref()
                .ok_or_else(|| AppError::InternalServerError(
                    "No redirect_uri in oauth state for linking flow".to_string()
                ))?;
            return Ok(Redirect::to(redirect_url).into_response());
        }
    }

    // Normal login flow - find or create user
    let user = find_or_create_user(&state.pool, &user_info.email).await?;

    // Update identity with full token details
    upsert_identity_with_details(
        &state.pool,
        state.encryption.as_ref(),
        &user.id,
        provider,
        &user_info.provider_user_id,
        &token_details.access_token,
        token_details.refresh_token.as_deref(),
        token_details.expires_at,
        &token_details.scopes,
        issuing_org_id.as_deref(),
        issuing_service_id.as_deref(),
    )
    .await?;

    // Handle device flow completion
    if let Some(ref oauth_ctx) = oauth_state {
        if oauth_ctx.redirect_uri.is_none()
            && (oauth_ctx.org_slug.is_some() || oauth_ctx.service_slug.is_some())
        {
            // This is a device flow callback - find and update the device code
            if let (Some(org_slug), Some(service_slug)) =
                (&oauth_ctx.org_slug, &oauth_ctx.service_slug)
            {
                // Find device code using the user_code if provided, otherwise fall back to most recent
                let device_code = if let Some(ref user_code) = oauth_ctx.device_user_code {
                    sqlx::query_as::<_, DeviceCode>(
                        "SELECT * FROM device_codes WHERE user_code = ? AND status = 'pending'"
                    )
                    .bind(user_code)
                    .fetch_optional(&state.pool)
                    .await?
                } else {
                    sqlx::query_as::<_, DeviceCode>(
                        "SELECT * FROM device_codes
                         WHERE org_slug = ? AND service_slug = ? AND status = 'pending'
                         ORDER BY created_at DESC LIMIT 1",
                    )
                    .bind(org_slug)
                    .bind(service_slug)
                    .fetch_optional(&state.pool)
                    .await?
                };

                if let Some(dc) = device_code {
                    // Authorize the device code
                    sqlx::query!(
                        "UPDATE device_codes SET user_id = ?, status = 'authorized' WHERE id = ?",
                        user.id,
                        dc.id
                    )
                    .execute(&state.pool)
                    .await?;
                }

                // This is a device flow completion - redirect to service's success page
                // Get service to find device activation URI
                let service = sqlx::query_as::<_, crate::db::models::Service>(
                    "SELECT s.* FROM services s JOIN organizations o ON s.org_id = o.id
                     WHERE o.slug = ? AND s.slug = ?",
                )
                .bind(org_slug)
                .bind(service_slug)
                .fetch_optional(&state.pool)
                .await?;

                // Use the service's configured device activation URI
                let base_activation_uri = service
                    .and_then(|s| s.device_activation_uri)
                    .ok_or_else(|| AppError::InternalServerError("Device activation URI not configured for this service".to_string()))?;

                // Create success redirect URL with token
                let mut success_url = url::Url::parse(&base_activation_uri)
                    .map_err(|_| AppError::InternalServerError("Invalid device activation URI configured".to_string()))?;

                // Set path to success page and include status and token
                success_url.set_path("/activate/success");
                success_url.query_pairs_mut()
                    .append_pair("status", "success")
                    .append_pair("device_flow", "true");

                return Ok(Redirect::to(success_url.as_str()).into_response());
            }
        }
    }

    // If redirect_uri provided, issue JWT and redirect
    if let Some(ref oauth_ctx) = oauth_state {
        if let Some(ref redirect_uri) = oauth_ctx.redirect_uri {
            // Get service and subscription info for JWT
            let (service_slug, plan_name, features) =
                if let (Some(org), Some(svc)) = (&oauth_ctx.org_slug, &oauth_ctx.service_slug) {
                    // Get service
                    let service = sqlx::query_as::<_, crate::db::models::Service>(
                        "SELECT s.* FROM services s JOIN organizations o ON s.org_id = o.id
                     WHERE o.slug = ? AND s.slug = ?",
                    )
                    .bind(org)
                    .bind(svc)
                    .fetch_optional(&state.pool)
                    .await?;

                    if let Some(service) = service {
                        // Validate redirect_uri again before redirecting
                        validate_redirect_uri(redirect_uri, &service)?;
                        // Get subscription if exists
                        let subscription = sqlx::query!(
                            r#"
                        SELECT p.name as plan_name, p.features
                        FROM subscriptions sub
                        JOIN plans p ON sub.plan_id = p.id
                        WHERE sub.user_id = ? AND sub.service_id = ? AND sub.status = 'active'
                        "#,
                            user.id,
                            service.id
                        )
                        .fetch_optional(&state.pool)
                        .await?;

                        let plan = subscription
                            .as_ref()
                            .map(|s| s.plan_name.clone())
                            .unwrap_or_else(|| "free".to_string());
                        let feats = subscription
                            .as_ref()
                            .and_then(|s| s.features.as_ref())
                            .and_then(|f| serde_json::from_str::<Vec<String>>(f).ok());

                        (Some(svc.clone()), Some(plan), feats)
                    } else {
                        (None, None, None)
                    }
                } else {
                    (None, None, None)
                };

            // Create JWT
            let jwt = state.jwt_service.create_token(
                &user.id,
                &user.email,
                user.is_platform_owner,
                oauth_ctx.org_slug.as_deref(),
                service_slug.as_deref(),
                plan_name.as_deref(),
                features,
            )?;

            // Generate refresh token
            let refresh_token = uuid::Uuid::new_v4().to_string();

            // Store session with refresh token
            let session_id = uuid::Uuid::new_v4().to_string();
            let token_hash = JwtService::hash_token(&jwt);
            let now = Utc::now();
            let expires_at = now + chrono::Duration::hours(JWT_EXPIRE_HOURS);
            let refresh_expires_at = now + chrono::Duration::days(30);
            let created_at = now;

            sqlx::query!(
                r#"
                INSERT INTO sessions
                (id, user_id, token_hash, expires_at, refresh_token, refresh_token_expires_at, org_slug, service_id, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                "#,
                session_id,
                user.id,
                token_hash,
                expires_at,
                refresh_token,
                refresh_expires_at,
                oauth_ctx.org_slug,
                oauth_ctx.service_id,
                created_at
            )
            .execute(&state.pool)
            .await?;

            // Record login event if service_id is available
            if let Some(ref service_id) = oauth_ctx.service_id {
                let _ = record_login_event(&state.pool, &user.id, service_id, provider).await;
            }

            // Redirect with both tokens as query parameters
            let redirect_url = format!("{}?access_token={}&refresh_token={}", redirect_uri, jwt, refresh_token);
            return Ok(Redirect::to(&redirect_url).into_response());
        }
    }

    // No redirect_uri - show HTML success page
    let html = format!(
        r#"
        <!DOCTYPE html>
        <html>
        <head><title>Authentication Successful</title></head>
        <body>
            <h1>Authentication Successful</h1>
            <p>User: {}</p>
            <p>Provider: {}</p>
        </body>
        </html>
        "#,
        user_info.email,
        provider.as_str()
    );

    Ok(Html(html).into_response())
}

/// Device Flow: Create device code
pub async fn device_code(
    State(state): State<AppState>,
    Json(req): Json<DeviceCodeRequest>,
) -> Result<Json<DeviceCodeResponse>> {
    // Get config for platform device activation URI
    let config = crate::config::Config::from_env()
        .map_err(|e| AppError::InternalServerError(e.to_string()))?;

    // Check if this is a platform-level device flow or service-level
    let verification_uri = if req.org == "platform" && req.service == "admin-cli" && req.client_id.starts_with("platform-") {
        // Platform-level device flow for admin CLI - use configured platform device activation URI
        config.platform_device_activation_uri
    } else {
        // Service-level device flow - validate service exists
        let service = sqlx::query_as::<_, crate::db::models::Service>(
            r#"
            SELECT s.* FROM services s
            JOIN organizations o ON s.org_id = o.id
            WHERE s.client_id = ? AND o.slug = ? AND s.slug = ?
            "#,
        )
        .bind(&req.client_id)
        .bind(&req.org)
        .bind(&req.service)
        .fetch_optional(&state.pool)
        .await?;

        let service = service.ok_or_else(|| AppError::BadRequest(
            "Invalid client credentials".to_string(),
        ))?;

        // Use service's device_activation_uri if set
        service.device_activation_uri.ok_or_else(|| AppError::BadRequest(
            "Device activation URI not configured for this service".to_string(),
        ))?
    };

    // --- Perform CPU-bound work here, in the parallel handler ---
    let id = Uuid::new_v4().to_string();
    let device_code = DeviceFlowService::generate_device_code();
    let user_code = DeviceFlowService::generate_user_code();
    // --- End CPU-bound work ---

    let (tx, rx) = oneshot::channel();
    let db_request = DbRequest::CreateDeviceCode {
        id,
        device_code: device_code.clone(),
        user_code: user_code.clone(),
        client_id: req.client_id,
        org_slug: req.org,
        service_slug: req.service,
        responder: tx,
    };

    state.db_tx.send(db_request).await.map_err(|e| {
        AppError::InternalServerError(format!("Failed to send to DB writer: {}", e))
    })?;

    let _ = rx.await.map_err(|e| {
        AppError::InternalServerError(format!("Failed to receive from DB writer: {}", e))
    })??;

    Ok(Json(DeviceCodeResponse {
        device_code,
        user_code,
        verification_uri,
        expires_in: DEVICE_CODE_EXPIRE_MINUTES * 60, // Convert minutes to seconds
        interval: 5,     // Poll every 5 seconds
    }))
}

/// Device Flow: Verify user code and return context for frontend
pub async fn device_verify(
    State(state): State<AppState>,
    Json(req): Json<DeviceVerifyRequest>,
) -> Result<Json<DeviceVerifyResponse>> {
    // Find device code
    let device_code = DeviceFlowService::find_by_user_code(&state.pool, &req.user_code)
        .await?
        .ok_or_else(|| AppError::BadRequest("Invalid user code".to_string()))?;

    // Check if expired
    if DeviceFlowService::is_expired(&device_code) {
        return Err(AppError::DeviceCodeExpired);
    }

    // Check if already authorized
    if DeviceFlowService::is_authorized(&device_code) {
        return Err(AppError::BadRequest("Device already authorized".to_string()));
    }

    // Check if this is a platform-level admin device flow
    if device_code.org_slug == "platform" && device_code.service_slug == "admin-cli" {
        // Platform-level device flow - return all available admin providers
        let available_providers = vec!["github".to_string(), "google".to_string(), "microsoft".to_string()];

        return Ok(Json(DeviceVerifyResponse {
            org_slug: device_code.org_slug,
            service_slug: device_code.service_slug,
            available_providers,
        }));
    }

    // Service-level device flow - fetch organization and service
    let org = sqlx::query_as::<_, crate::db::models::Organization>(
        "SELECT * FROM organizations WHERE slug = ?"
    )
    .bind(&device_code.org_slug)
    .fetch_optional(&state.pool)
    .await?
    .ok_or_else(|| AppError::NotFound("Organization not found".to_string()))?;

    let _service = sqlx::query_as::<_, crate::db::models::Service>(
        "SELECT * FROM services WHERE org_id = ? AND slug = ?"
    )
    .bind(&org.id)
    .bind(&device_code.service_slug)
    .fetch_optional(&state.pool)
    .await?
    .ok_or_else(|| AppError::NotFound("Service not found".to_string()))?;

    // Fetch organization OAuth credentials to see which providers are configured
    let org_credentials = sqlx::query_as::<_, crate::db::models::OrganizationOAuthCredential>(
        "SELECT * FROM organization_oauth_credentials WHERE org_id = ?"
    )
    .bind(&org.id)
    .fetch_all(&state.pool)
    .await?;

    let available_providers: Vec<String> = org_credentials
        .into_iter()
        .map(|cred| cred.provider)
        .collect();

    // Return the context needed for the frontend to initiate the correct login flow
    Ok(Json(DeviceVerifyResponse {
        org_slug: device_code.org_slug,
        service_slug: device_code.service_slug,
        available_providers,
    }))
}

/// Device Flow: Exchange device code for token
pub async fn token_exchange(
    State(state): State<AppState>,
    Json(req): Json<TokenRequest>,
) -> Result<Json<TokenResponse>> {
    // Validate grant type
    if req.grant_type != "urn:ietf:params:oauth:grant-type:device_code" {
        return Err(AppError::BadRequest("Invalid grant type".to_string()));
    }

    // Validate and get device code
    let device_code = DeviceFlowService::validate_for_token_exchange(
        &state.pool,
        &req.device_code,
        &req.client_id,
    )
    .await?;

    let user_id = device_code
        .user_id
        .ok_or_else(|| AppError::Unauthorized("Not authorized".to_string()))?;

    // Get user info
    let user = sqlx::query_as::<_, User>(
        "SELECT id, email, is_platform_owner, created_at FROM users WHERE id = ?",
    )
    .bind(&user_id)
    .fetch_one(&state.pool)
    .await?;

    // Check if this is a platform-level device flow
    if device_code.org_slug == "platform" && device_code.service_slug == "admin-cli" {
        // Generate platform JWT for admin CLI
        let token = state.jwt_service.create_token(
            &user.id,
            &user.email,
            user.is_platform_owner,
            None,
            None,
            None,
            None,
        )?;

        // Generate refresh token
        let refresh_token = Uuid::new_v4().to_string();

        // Store session with refresh token
        let session_id = Uuid::new_v4().to_string();
        let token_hash = JwtService::hash_token(&token);
        let now = Utc::now();
        let expires_at = now + chrono::Duration::hours(JWT_EXPIRE_HOURS);
        let refresh_expires_at = now + chrono::Duration::days(30);
        let created_at = now;

        sqlx::query!(
            r#"
            INSERT INTO sessions
            (id, user_id, token_hash, expires_at, refresh_token, refresh_token_expires_at, org_slug, service_id, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            "#,
            session_id,
            user_id,
            token_hash,
            expires_at,
            refresh_token,
            refresh_expires_at,
            None::<String>,
            None::<String>,
            created_at
        )
        .execute(&state.pool)
        .await?;

        return Ok(Json(TokenResponse {
            access_token: token,
            token_type: "Bearer".to_string(),
            expires_in: JWT_EXPIRE_HOURS * 3600, // Convert hours to seconds
        }));
    }

    // Service-level device flow - get service and plan info
    let result = sqlx::query!(
        r#"
        SELECT
            s.id as service_id,
            s.slug as service_slug,
            o.slug as org_slug,
            p.name as plan_name,
            p.features as features
        FROM services s
        JOIN organizations o ON s.org_id = o.id
        LEFT JOIN subscriptions sub ON sub.service_id = s.id AND sub.user_id = ?
        LEFT JOIN plans p ON sub.plan_id = p.id
        WHERE o.slug = ? AND s.slug = ?
        "#,
        user_id,
        device_code.org_slug,
        device_code.service_slug
    )
    .fetch_one(&state.pool)
    .await?;

    let plan_name = result.plan_name.unwrap_or_else(|| "free".to_string());
    let features: Vec<String> = result
        .features
        .as_ref()
        .and_then(|f| serde_json::from_str(f).ok())
        .unwrap_or_default();

    // Generate JWT
    let token = state.jwt_service.create_token(
        &user.id,
        &user.email,
        user.is_platform_owner,
        Some(&result.org_slug),
        Some(&result.service_slug),
        Some(&plan_name),
        Some(features),
    )?;

    // Generate refresh token
    let refresh_token = Uuid::new_v4().to_string();

    // Store session with refresh token
    let session_id = Uuid::new_v4().to_string();
    let token_hash = JwtService::hash_token(&token);
    let now = Utc::now();
    let expires_at = now + chrono::Duration::hours(JWT_EXPIRE_HOURS);
    let refresh_expires_at = now + chrono::Duration::days(30);
    let created_at = now;

    sqlx::query!(
        r#"
        INSERT INTO sessions
        (id, user_id, token_hash, expires_at, refresh_token, refresh_token_expires_at, org_slug, service_id, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        "#,
        session_id,
        user_id,
        token_hash,
        expires_at,
        refresh_token,
        refresh_expires_at,
        result.org_slug,
        result.service_id,
        created_at
    )
    .execute(&state.pool)
    .await?;

    // Record login event - get provider from most recent identity
    if let Some(service_id) = result.service_id.as_ref() {
        if let Ok(provider_str) = sqlx::query_scalar::<_, String>(
            "SELECT provider FROM identities WHERE user_id = ? ORDER BY last_refreshed_at DESC LIMIT 1"
        )
        .bind(&user_id)
        .fetch_one(&state.pool)
        .await
        {
            if let Ok(provider) = Provider::from_str(&provider_str) {
                let _ = record_login_event(&state.pool, &user_id, service_id, provider).await;
            }
        }
    }

    Ok(Json(TokenResponse {
        access_token: token,
        token_type: "Bearer".to_string(),
        expires_in: JWT_EXPIRE_HOURS * 3600, // Convert hours to seconds
    }))
}

// Helper functions

async fn find_or_create_user(pool: &SqlitePool, email: &str) -> Result<User> {
    // Try to find existing user
    if let Some(user) = sqlx::query_as::<_, User>("SELECT * FROM users WHERE email = ?")
        .bind(email)
        .fetch_optional(pool)
        .await?
    {
        return Ok(user);
    }

    // Create new user
    let id = Uuid::new_v4().to_string();
    let user = sqlx::query_as::<_, User>(
        r#"
        INSERT INTO users (id, email, is_platform_owner, created_at)
        VALUES (?, ?, 0, ?)
        RETURNING *
        "#,
    )
    .bind(&id)
    .bind(email)
    .bind(Utc::now())
    .fetch_one(pool)
    .await?;

    Ok(user)
}

#[allow(clippy::too_many_arguments)]
async fn upsert_identity_with_details(
    pool: &SqlitePool,
    encryption: Option<&Arc<crate::encryption::EncryptionService>>,
    user_id: &str,
    provider: Provider,
    provider_user_id: &str,
    access_token: &str,
    refresh_token: Option<&str>,
    expires_at: Option<chrono::DateTime<Utc>>,
    scopes: &[String],
    issuing_org_id: Option<&str>,
    issuing_service_id: Option<&str>,
) -> Result<Identity> {
    let id = Uuid::new_v4().to_string();
    let provider_str = provider.as_str();
    let scopes_json =
        serde_json::to_string(scopes).map_err(|e| AppError::InternalServerError(e.to_string()))?;

    // Encrypt tokens if encryption service is available
    // Use different queries for platform vs service context due to different partial unique indexes
    let identity = if let Some(enc) = encryption {
        let access_token_encrypted = enc
            .encrypt(access_token)
            .map_err(|e| AppError::InternalServerError(format!("Failed to encrypt access token: {}", e)))?;

        let refresh_token_encrypted = refresh_token
            .map(|rt| enc.encrypt(rt))
            .transpose()
            .map_err(|e| AppError::InternalServerError(format!("Failed to encrypt refresh token: {}", e)))?;

        if issuing_service_id.is_some() {
            // Service context: use service-level partial unique index
            sqlx::query_as::<_, Identity>(
                r#"
                INSERT INTO identities (id, user_id, provider, provider_user_id, access_token, refresh_token, access_token_encrypted, refresh_token_encrypted, encryption_key_id, expires_at, scopes, issuing_org_id, issuing_service_id)
                VALUES (?, ?, ?, ?, NULL, NULL, ?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(user_id, provider, issuing_org_id, issuing_service_id) WHERE issuing_org_id IS NOT NULL AND issuing_service_id IS NOT NULL
                DO UPDATE SET
                    access_token = NULL,
                    refresh_token = NULL,
                    access_token_encrypted = excluded.access_token_encrypted,
                    refresh_token_encrypted = COALESCE(excluded.refresh_token_encrypted, refresh_token_encrypted),
                    encryption_key_id = excluded.encryption_key_id,
                    expires_at = excluded.expires_at,
                    provider_user_id = excluded.provider_user_id,
                    scopes = excluded.scopes,
                    last_refreshed_at = datetime('now')
                RETURNING *
                "#,
            )
            .bind(&id)
            .bind(user_id)
            .bind(provider_str)
            .bind(provider_user_id)
            .bind(&access_token_encrypted)
            .bind(&refresh_token_encrypted)
            .bind(enc.key_id())
            .bind(expires_at)
            .bind(scopes_json)
            .bind(issuing_org_id)
            .bind(issuing_service_id)
            .fetch_one(pool)
            .await?
        } else {
            // Platform context: use platform-level partial unique index
            sqlx::query_as::<_, Identity>(
                r#"
                INSERT INTO identities (id, user_id, provider, provider_user_id, access_token, refresh_token, access_token_encrypted, refresh_token_encrypted, encryption_key_id, expires_at, scopes, issuing_org_id, issuing_service_id)
                VALUES (?, ?, ?, ?, NULL, NULL, ?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(user_id, provider) WHERE issuing_org_id IS NULL AND issuing_service_id IS NULL
                DO UPDATE SET
                    access_token = NULL,
                    refresh_token = NULL,
                    access_token_encrypted = excluded.access_token_encrypted,
                    refresh_token_encrypted = COALESCE(excluded.refresh_token_encrypted, refresh_token_encrypted),
                    encryption_key_id = excluded.encryption_key_id,
                    expires_at = excluded.expires_at,
                    provider_user_id = excluded.provider_user_id,
                    scopes = excluded.scopes,
                    last_refreshed_at = datetime('now')
                RETURNING *
                "#,
            )
            .bind(&id)
            .bind(user_id)
            .bind(provider_str)
            .bind(provider_user_id)
            .bind(&access_token_encrypted)
            .bind(&refresh_token_encrypted)
            .bind(enc.key_id())
            .bind(expires_at)
            .bind(scopes_json)
            .bind(issuing_org_id)
            .bind(issuing_service_id)
            .fetch_one(pool)
            .await?
        }
    } else {
        // No encryption - store in plaintext (fallback for backward compatibility)
        if issuing_service_id.is_some() {
            // Service context: use service-level partial unique index
            sqlx::query_as::<_, Identity>(
                r#"
                INSERT INTO identities (id, user_id, provider, provider_user_id, access_token, refresh_token, expires_at, scopes, issuing_org_id, issuing_service_id)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(user_id, provider, issuing_org_id, issuing_service_id) WHERE issuing_org_id IS NOT NULL AND issuing_service_id IS NOT NULL
                DO UPDATE SET
                    access_token = excluded.access_token,
                    refresh_token = COALESCE(excluded.refresh_token, refresh_token),
                    expires_at = excluded.expires_at,
                    provider_user_id = excluded.provider_user_id,
                    scopes = excluded.scopes,
                    last_refreshed_at = datetime('now')
                RETURNING *
                "#,
            )
            .bind(&id)
            .bind(user_id)
            .bind(provider_str)
            .bind(provider_user_id)
            .bind(access_token)
            .bind(refresh_token)
            .bind(expires_at)
            .bind(scopes_json)
            .bind(issuing_org_id)
            .bind(issuing_service_id)
            .fetch_one(pool)
            .await?
        } else {
            // Platform context: use platform-level partial unique index
            sqlx::query_as::<_, Identity>(
                r#"
                INSERT INTO identities (id, user_id, provider, provider_user_id, access_token, refresh_token, expires_at, scopes, issuing_org_id, issuing_service_id)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(user_id, provider) WHERE issuing_org_id IS NULL AND issuing_service_id IS NULL
                DO UPDATE SET
                    access_token = excluded.access_token,
                    refresh_token = COALESCE(excluded.refresh_token, refresh_token),
                    expires_at = excluded.expires_at,
                    provider_user_id = excluded.provider_user_id,
                    scopes = excluded.scopes,
                    last_refreshed_at = datetime('now')
                RETURNING *
                "#,
            )
            .bind(&id)
            .bind(user_id)
            .bind(provider_str)
            .bind(provider_user_id)
            .bind(access_token)
            .bind(refresh_token)
            .bind(expires_at)
            .bind(scopes_json)
            .bind(issuing_org_id)
            .bind(issuing_service_id)
            .fetch_one(pool)
            .await?
        }
    };

    Ok(identity)
}

/// Refresh Token: Exchange a refresh token for a new access token
/// Implements token rotation for enhanced security
#[derive(Debug, Deserialize)]
pub struct RefreshTokenRequest {
    pub refresh_token: String,
}

#[derive(Debug, Serialize)]
pub struct RefreshTokenResponse {
    pub access_token: String,
    pub refresh_token: String,
    pub expires_in: i64,
}

pub async fn refresh_token(
    State(state): State<AppState>,
    Json(req): Json<RefreshTokenRequest>,
) -> Result<Json<RefreshTokenResponse>> {
    // Find the session by refresh token
    let session = sqlx::query_as::<_, crate::db::models::Session>(
        "SELECT * FROM sessions WHERE refresh_token = ?",
    )
    .bind(&req.refresh_token)
    .fetch_optional(&state.pool)
    .await?
    .ok_or_else(|| AppError::Unauthorized("Invalid refresh token".to_string()))?;

    // Check if refresh token has expired
    if let Some(refresh_expires_at) = session.refresh_token_expires_at {
        if refresh_expires_at < Utc::now() {
            // Token expired, clean up and deny
            sqlx::query!("DELETE FROM sessions WHERE id = ?", session.id)
                .execute(&state.pool)
                .await?;
            return Err(AppError::Unauthorized("Refresh token expired".to_string()));
        }
    } else {
        // No expiration set - invalid session
        return Err(AppError::Unauthorized("Invalid session".to_string()));
    }

    // Get the user
    let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE id = ?")
        .bind(&session.user_id)
        .fetch_one(&state.pool)
        .await?;

    // Reconstruct JWT with original session context
    // If service_id is present, get full service and subscription details
    let (service_slug, plan_name, features) = if let Some(ref svc_id) = session.service_id {
        let service = sqlx::query_as::<_, crate::db::models::Service>(
            "SELECT * FROM services WHERE id = ?",
        )
        .bind(svc_id)
        .fetch_optional(&state.pool)
        .await?;

        if let Some(svc) = service {
            // Get subscription if exists
            let subscription = sqlx::query!(
                r#"
                SELECT p.name as plan_name, p.features
                FROM subscriptions sub
                JOIN plans p ON sub.plan_id = p.id
                WHERE sub.user_id = ? AND sub.service_id = ? AND sub.status = 'active'
                "#,
                user.id,
                svc.id
            )
            .fetch_optional(&state.pool)
            .await?;

            let plan = subscription
                .as_ref()
                .map(|s| s.plan_name.clone())
                .unwrap_or_else(|| "free".to_string());
            let feats = subscription
                .as_ref()
                .and_then(|s| s.features.as_ref())
                .and_then(|f| serde_json::from_str::<Vec<String>>(f).ok());

            (Some(svc.slug), Some(plan), feats)
        } else {
            (None, None, None)
        }
    } else {
        (None, None, None)
    };

    // Create new access token with preserved context
    let new_access_token = state.jwt_service.create_token(
        &user.id,
        &user.email,
        user.is_platform_owner,
        session.org_slug.as_deref(),
        service_slug.as_deref(),
        plan_name.as_deref(),
        features,
    )?;

    // Implement token rotation: generate new refresh token
    let new_refresh_token = Uuid::new_v4().to_string();
    let new_token_hash = JwtService::hash_token(&new_access_token);
    let new_access_expires_at = Utc::now() + chrono::Duration::hours(JWT_EXPIRE_HOURS);
    let new_refresh_expires_at = Utc::now() + chrono::Duration::days(30);

    // Update session with new tokens (token rotation)
    sqlx::query!(
        r#"
        UPDATE sessions
        SET token_hash = ?,
            expires_at = ?,
            refresh_token = ?,
            refresh_token_expires_at = ?
        WHERE id = ?
        "#,
        new_token_hash,
        new_access_expires_at,
        new_refresh_token,
        new_refresh_expires_at,
        session.id
    )
    .execute(&state.pool)
    .await?;

    Ok(Json(RefreshTokenResponse {
        access_token: new_access_token,
        refresh_token: new_refresh_token,
        expires_in: JWT_EXPIRE_HOURS * 3600,
    }))
}

/// Logout: Invalidate JWT session
pub async fn logout(
    State(state): State<AppState>,
    headers: axum::http::HeaderMap,
) -> Result<impl IntoResponse> {
    // Extract token from Authorization header
    let token = headers
        .get("Authorization")
        .and_then(|header| header.to_str().ok())
        .and_then(|header| header.strip_prefix("Bearer "))
        .ok_or_else(|| {
            AppError::Unauthorized("Missing or invalid Authorization header".to_string())
        })?;

    // Hash token
    let token_hash = JwtService::hash_token(token);

    // Delete session (also removes refresh token)
    sqlx::query!("DELETE FROM sessions WHERE token_hash = ?", token_hash)
        .execute(&state.pool)
        .await
        .map_err(AppError::Database)?;

    Ok(axum::http::StatusCode::NO_CONTENT)
}

/// Admin Auth: Initiate OAuth flow for platform/org admin login
pub async fn auth_admin_provider(
    State(state): State<AppState>,
    Path(provider_str): Path<String>,
    Query(params): Query<AdminAuthRequest>,
) -> Result<Response> {
    let provider = Provider::from_str(&provider_str)?;

    // Build admin OAuth client dynamically using PLATFORM_* credentials
    let config = crate::config::Config::from_env()
        .map_err(|e| AppError::InternalServerError(e.to_string()))?;

    let admin_oauth_client = create_admin_oauth_client(&config, provider)?;

    // Use default admin scopes based on provider
    let scopes = default_scopes_for_provider(provider);

    // Generate authorization URL with PKCE (for Microsoft)
    let (auth_url, csrf_token, pkce_verifier) =
        get_admin_authorization_url(&admin_oauth_client, provider, scopes);

    // Store OAuth state with is_admin_flow = true
    let expires_at = Utc::now() + chrono::Duration::minutes(OAUTH_STATE_EXPIRE_MINUTES);
    let pkce_value = if provider == Provider::Microsoft && !pkce_verifier.is_empty() {
        Some(pkce_verifier)
    } else {
        None
    };

    let is_admin_flow = true;
    sqlx::query(
        "INSERT INTO oauth_states (state, pkce_verifier, service_id, redirect_uri, org_slug, service_slug, is_admin_flow, user_id_for_linking, device_user_code, created_at, expires_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, NULL, ?, datetime('now'), ?)",
    )
    .bind(csrf_token.secret())
    .bind(pkce_value)
    .bind(Option::<String>::None)
    .bind(Option::<String>::None)
    .bind(&params.org_slug)
    .bind(Option::<String>::None)
    .bind(is_admin_flow)
    .bind(&params.user_code)
    .bind(expires_at)
    .execute(&state.pool)
    .await?;

    Ok(Redirect::to(&auth_url).into_response())
}

/// Admin Auth: Handle OAuth callback for admin login
pub async fn auth_admin_callback(
    State(state): State<AppState>,
    Path(provider_str): Path<String>,
    Query(callback): Query<CallbackQuery>,
) -> Result<Response> {
    // Load config early so we can use it for error redirects
    let config = crate::config::Config::from_env()
        .map_err(|e| AppError::InternalServerError(e.to_string()))?;

    // Wrap the main logic to catch errors and redirect to frontend with error info
    match auth_admin_callback_impl(state, provider_str, callback).await {
        Ok(response) => Ok(response),
        Err(e) => {
            // Log the error
            tracing::error!("OAuth callback error: {}", e);

            // Redirect to frontend with error information
            let error_message = match &e {
                AppError::OAuth(msg) => msg.clone(),
                AppError::BadRequest(msg) => msg.clone(),
                AppError::Unauthorized(msg) => msg.clone(),
                _ => "Authentication failed".to_string(),
            };

            let mut redirect_url = url::Url::parse(&config.platform_admin_redirect_uri)
                .map_err(|_| AppError::InternalServerError("Invalid platform admin redirect URI".to_string()))?;

            redirect_url.query_pairs_mut()
                .append_pair("error", "oauth_error")
                .append_pair("error_description", &error_message);

            Ok(Redirect::to(redirect_url.as_str()).into_response())
        }
    }
}

/// Internal implementation of admin callback that can return errors
async fn auth_admin_callback_impl(
    state: AppState,
    provider_str: String,
    callback: CallbackQuery,
) -> Result<Response> {
    let provider = Provider::from_str(&provider_str)?;

    // Get OAuth state and verify it's an admin flow
    let oauth_state = if let Some(ref state_param) = callback.state {
        sqlx::query_as::<_, crate::db::models::OAuthState>(
            "SELECT * FROM oauth_states WHERE state = ?",
        )
        .bind(state_param)
        .fetch_optional(&state.pool)
        .await?
    } else {
        None
    };

    let oauth_state =
        oauth_state.ok_or_else(|| AppError::BadRequest("Invalid state parameter".to_string()))?;

    if !oauth_state.is_admin_flow {
        return Err(AppError::BadRequest("Not an admin flow".to_string()));
    }

    // Clean up OAuth state immediately to prevent replay attacks
    // Do this before token exchange so even if exchange fails, state cannot be reused
    if let Some(ref state_param) = callback.state {
        let _ = sqlx::query("DELETE FROM oauth_states WHERE state = ?")
            .bind(state_param)
            .execute(&state.pool)
            .await;
    }

    // Build admin OAuth client with PLATFORM_* credentials
    let config = crate::config::Config::from_env()
        .map_err(|e| AppError::InternalServerError(e.to_string()))?;

    let admin_oauth_client = create_admin_oauth_client(&config, provider)?;

    // Exchange code with PKCE verifier
    let pkce_verifier = oauth_state.pkce_verifier.as_deref();
    let token_details =
        exchange_admin_code(&admin_oauth_client, provider, &callback.code, pkce_verifier).await?;

    // Get user info from provider (standalone, not using OAuth client)
    let user_info = get_provider_user_info(provider, &token_details.access_token).await?;

    // Find or create user
    let user = find_or_create_user(&state.pool, &user_info.email).await?;

    // Update identity (admin flow always uses platform credentials, so issuing_org_id and issuing_service_id are None)
    upsert_identity_with_details(
        &state.pool,
        state.encryption.as_ref(),
        &user.id,
        provider,
        &user_info.provider_user_id,
        &token_details.access_token,
        token_details.refresh_token.as_deref(),
        token_details.expires_at,
        &token_details.scopes,
        None,
        None,
    )
    .await?;

    // Check if this is a device flow completion - prioritize this over normal web login
    if let Some(ref user_code) = oauth_state.device_user_code {
        // Find the specific device code by user_code
        let device_code = sqlx::query_as::<_, DeviceCode>(
            "SELECT * FROM device_codes WHERE user_code = ? AND status = 'pending'",
        )
        .bind(user_code)
        .fetch_optional(&state.pool)
        .await?;

        if let Some(dc) = device_code {
            // Authorize the device code
            sqlx::query!(
                "UPDATE device_codes SET user_id = ?, status = 'authorized' WHERE id = ?",
                user.id,
                dc.id
            )
            .execute(&state.pool)
            .await?;

            // Determine redirect URL based on org/service
            let redirect_url = if dc.org_slug == "platform" && dc.service_slug == "admin-cli" {
                // Platform admin CLI device flow - redirect to platform admin frontend
                format!("{}?device_flow_status=success", config.platform_admin_redirect_uri)
            } else {
                // Service-level device flow - get service's device activation URI
                let service = sqlx::query_as::<_, crate::db::models::Service>(
                    "SELECT s.* FROM services s JOIN organizations o ON s.org_id = o.id
                     WHERE o.slug = ? AND s.slug = ?",
                )
                .bind(&dc.org_slug)
                .bind(&dc.service_slug)
                .fetch_optional(&state.pool)
                .await?;

                let base_activation_uri = service
                    .and_then(|s| s.device_activation_uri)
                    .ok_or_else(|| AppError::InternalServerError("Device activation URI not configured for this service".to_string()))?;

                let mut success_url = url::Url::parse(&base_activation_uri)
                    .map_err(|_| AppError::InternalServerError("Invalid device activation URI configured".to_string()))?;

                success_url.set_path("/activate/success");
                success_url.query_pairs_mut()
                    .append_pair("status", "success")
                    .append_pair("device_flow", "true");

                success_url.to_string()
            };

            return Ok(Redirect::to(&redirect_url).into_response());
        }
    }

    // If not a device flow, proceed with normal web login decision logic
    let jwt = if user.is_platform_owner {
        // Create Platform JWT (no org or service claims)
        state
            .jwt_service
            .create_token(&user.id, &user.email, true, None, None, None, None)?
    } else if let Some(org_slug) = &oauth_state.org_slug {
        // Check if user is a member of the requested organization
        let membership = sqlx::query_as::<_, crate::db::models::Membership>(
            "SELECT m.* FROM memberships m
             JOIN organizations o ON m.org_id = o.id
             WHERE o.slug = ? AND m.user_id = ?",
        )
        .bind(org_slug)
        .bind(&user.id)
        .fetch_optional(&state.pool)
        .await?;

        if let Some(_membership) = membership {
            // Create Org Management JWT (org claim present, service claim null)
            state.jwt_service.create_token(
                &user.id,
                &user.email,
                false,
                Some(org_slug),
                None,
                None,
                None,
            )?
        } else {
            // User is not a member - issue basic JWT so they can access signup page
            state.jwt_service.create_token(
                &user.id,
                &user.email,
                false,
                None,
                None,
                None,
                None,
            )?
        }
    } else {
        // Generic Admin Login (No org_slug provided):
        // Check if the user belongs to any organizations.
        let memberships = sqlx::query!(
            r#"
            SELECT o.slug
            FROM memberships m
            JOIN organizations o ON m.org_id = o.id
            WHERE m.user_id = ?
            ORDER BY m.created_at ASC
            "#,
            user.id
        )
        .fetch_all(&state.pool)
        .await?;

        if let Some(first_membership) = memberships.first() {
            // User is a member of at least one org. Issue a token for the first one.
            state.jwt_service.create_token(
                &user.id,
                &user.email,
                false,
                Some(&first_membership.slug),
                None,
                None,
                None,
            )?
        } else {
            // User is not a member of any org: Issue a basic JWT to prompt for creation.
            state.jwt_service.create_token(
                &user.id,
                &user.email,
                false,
                None,
                None,
                None,
                None,
            )?
        }
    };

    // Generate refresh token
    let refresh_token = Uuid::new_v4().to_string();

    // Store session with refresh token
    let session_id = Uuid::new_v4().to_string();
    let token_hash = JwtService::hash_token(&jwt);
    let now = Utc::now();
    let expires_at = now + chrono::Duration::hours(JWT_EXPIRE_HOURS);
    let refresh_expires_at = now + chrono::Duration::days(30);
    let created_at = now;

    sqlx::query!(
        r#"
        INSERT INTO sessions
        (id, user_id, token_hash, expires_at, refresh_token, refresh_token_expires_at, org_slug, service_id, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        "#,
        session_id,
        user.id,
        token_hash,
        expires_at,
        refresh_token,
        refresh_expires_at,
        oauth_state.org_slug,
        None::<String>,
        created_at
    )
    .execute(&state.pool)
    .await?;

    // Load config for redirect URL
    let config = crate::config::Config::from_env()
        .map_err(|e| AppError::InternalServerError(e.to_string()))?;

    // Redirect to platform admin frontend with both tokens
    let redirect_url = format!("{}?access_token={}&refresh_token={}", config.platform_admin_redirect_uri, jwt, refresh_token);
    Ok(Redirect::to(&redirect_url).into_response())
}

// Helper functions for admin OAuth

/// Unified OAuth client builder to reduce code duplication.
/// Creates an OAuth2 BasicClient for any provider with the given credentials and callback URI.
fn build_oauth_client(
    provider: Provider,
    client_id: String,
    client_secret: String,
    callback_uri: String,
) -> Result<oauth2::basic::BasicClient> {
    use oauth2::{basic::BasicClient, AuthUrl, ClientId, ClientSecret, RedirectUrl, TokenUrl};

    let (auth_url, token_url) = match provider {
        Provider::Github => (
            "https://github.com/login/oauth/authorize",
            "https://github.com/login/oauth/access_token",
        ),
        Provider::Google => (
            "https://accounts.google.com/o/oauth2/v2/auth",
            "https://oauth2.googleapis.com/token",
        ),
        Provider::Microsoft => (
            "https://login.microsoftonline.com/common/oauth2/v2.0/authorize",
            "https://login.microsoftonline.com/common/oauth2/v2.0/token",
        ),
    };

    Ok(BasicClient::new(
        ClientId::new(client_id),
        Some(ClientSecret::new(client_secret)),
        AuthUrl::new(auth_url.to_string()).map_err(|e| AppError::OAuth(e.to_string()))?,
        Some(TokenUrl::new(token_url.to_string()).map_err(|e| AppError::OAuth(e.to_string()))?),
    )
    .set_redirect_uri(RedirectUrl::new(callback_uri).map_err(|e| AppError::OAuth(e.to_string()))?))
}

fn create_admin_oauth_client(
    config: &crate::config::Config,
    provider: Provider,
) -> Result<oauth2::basic::BasicClient> {
    let (client_id, client_secret) = match provider {
        Provider::Github => (
            config.platform_github_client_id.clone(),
            config.platform_github_client_secret.clone(),
        ),
        Provider::Google => (
            config.platform_google_client_id.clone(),
            config.platform_google_client_secret.clone(),
        ),
        Provider::Microsoft => (
            config.platform_microsoft_client_id.clone(),
            config.platform_microsoft_client_secret.clone(),
        ),
    };

    let callback_uri = format!("{}/auth/admin/{}/callback", config.base_url, provider.as_str());

    build_oauth_client(provider, client_id, client_secret, callback_uri)
}

fn get_admin_authorization_url(
    client: &oauth2::basic::BasicClient,
    provider: Provider,
    scopes: Vec<String>,
) -> (String, CsrfToken, String) {
    use oauth2::Scope;

    let scopes_oauth: Vec<Scope> = scopes.into_iter().map(Scope::new).collect();

    // Generate PKCE challenge (only for Microsoft)
    let (pkce_challenge, pkce_verifier) = if provider == Provider::Microsoft {
        let (challenge, verifier) = PkceCodeChallenge::new_random_sha256();
        (Some(challenge), Some(verifier))
    } else {
        (None, None)
    };

    let mut auth_request = client
        .authorize_url(CsrfToken::new_random)
        .add_scopes(scopes_oauth);

    if let Some(challenge) = pkce_challenge {
        auth_request = auth_request.set_pkce_challenge(challenge);
    }

    let (auth_url, csrf_token) = auth_request.url();

    let verifier_secret = pkce_verifier
        .map(|v| v.secret().clone())
        .unwrap_or_default();

    (auth_url.to_string(), csrf_token, verifier_secret)
}

async fn exchange_admin_code(
    client: &oauth2::basic::BasicClient,
    _provider: Provider,
    code: &str,
    pkce_verifier: Option<&str>,
) -> Result<crate::auth::sso::TokenDetails> {
    use oauth2::{AuthorizationCode, TokenResponse};

    let mut token_request = client.exchange_code(AuthorizationCode::new(code.to_string()));

    if let Some(verifier) = pkce_verifier {
        token_request =
            token_request.set_pkce_verifier(PkceCodeVerifier::new(verifier.to_string()));
    }

    let token = token_request
        .request_async(oauth_http_client)
        .await
        .map_err(|e| AppError::OAuth(format!("Token exchange failed: {}", e)))?;

    let expires_at = token
        .expires_in()
        .map(|duration| Utc::now() + chrono::Duration::seconds(duration.as_secs() as i64));

    let scopes = token
        .scopes()
        .map(|scopes| scopes.iter().map(|s| s.to_string()).collect::<Vec<_>>())
        .unwrap_or_default();

    Ok(crate::auth::sso::TokenDetails {
        access_token: token.access_token().secret().clone(),
        refresh_token: token.refresh_token().map(|rt| rt.secret().clone()),
        expires_at,
        scopes,
    })
}

async fn exchange_custom_code(
    client: &oauth2::basic::BasicClient,
    _provider: Provider,
    code: &str,
    pkce_verifier: Option<&str>,
) -> Result<crate::auth::sso::TokenDetails> {
    use oauth2::{AuthorizationCode, TokenResponse};

    let mut token_request = client.exchange_code(AuthorizationCode::new(code.to_string()));

    if let Some(verifier) = pkce_verifier {
        token_request =
            token_request.set_pkce_verifier(PkceCodeVerifier::new(verifier.to_string()));
    }

    let token = token_request
        .request_async(oauth_http_client)
        .await
        .map_err(|e| AppError::OAuth(format!("Token exchange failed: {}", e)))?;

    let expires_at = token
        .expires_in()
        .map(|duration| Utc::now() + chrono::Duration::seconds(duration.as_secs() as i64));

    let scopes = token
        .scopes()
        .map(|scopes| scopes.iter().map(|s| s.to_string()).collect::<Vec<_>>())
        .unwrap_or_default();

    Ok(crate::auth::sso::TokenDetails {
        access_token: token.access_token().secret().clone(),
        refresh_token: token.refresh_token().map(|rt| rt.secret().clone()),
        expires_at,
        scopes,
    })
}

// Helper functions for BYOO (Bring Your Own OAuth)

fn validate_redirect_uri(redirect_uri: &str, service: &crate::db::models::Service) -> Result<()> {
    if let Some(ref allowed_uris_json) = service.redirect_uris {
        let allowed_uris: Vec<String> = serde_json::from_str(allowed_uris_json).map_err(|e| {
            AppError::InternalServerError(format!("Invalid redirect_uris JSON: {}", e))
        })?;

        if !allowed_uris.contains(&redirect_uri.to_string()) {
            return Err(AppError::BadRequest(format!(
                "redirect_uri '{}' is not registered for this service",
                redirect_uri
            )));
        }
    }
    // If no redirect_uris configured, allow any (backward compatibility)
    Ok(())
}

pub fn create_custom_oauth_client(
    config: &crate::config::Config,
    provider: Provider,
    client_id: &str,
    client_secret: &str,
) -> Result<oauth2::basic::BasicClient> {
    let callback_uri = format!("{}/auth/{}/callback", config.base_url, provider.as_str());
    build_oauth_client(
        provider,
        client_id.to_string(),
        client_secret.to_string(),
        callback_uri,
    )
}

pub fn get_authorization_url_for_client(
    client: &oauth2::basic::BasicClient,
    provider: Provider,
    scopes: Vec<String>,
) -> (String, CsrfToken, String) {
    use oauth2::Scope;

    let scopes_oauth: Vec<Scope> = scopes.into_iter().map(Scope::new).collect();

    // Generate PKCE challenge (only for Microsoft)
    let (pkce_challenge, pkce_verifier) = if provider == Provider::Microsoft {
        let (challenge, verifier) = PkceCodeChallenge::new_random_sha256();
        (Some(challenge), Some(verifier))
    } else {
        (None, None)
    };

    let mut auth_request = client
        .authorize_url(CsrfToken::new_random)
        .add_scopes(scopes_oauth);

    if let Some(challenge) = pkce_challenge {
        auth_request = auth_request.set_pkce_challenge(challenge);
    }

    let (auth_url, csrf_token) = auth_request.url();

    let verifier_secret = pkce_verifier
        .map(|v| v.secret().clone())
        .unwrap_or_default();

    (auth_url.to_string(), csrf_token, verifier_secret)
}

/// Get user info from provider (standalone, not using OAuth client for BYOO isolation)
async fn get_provider_user_info(provider: Provider, access_token: &str) -> Result<crate::auth::sso::UserInfo> {
    use serde::Deserialize;

    match provider {
        Provider::Github => {
            #[derive(Deserialize)]
            struct GithubUser {
                id: u64,
                email: Option<String>,
                name: Option<String>,
            }

            #[derive(Deserialize)]
            struct GithubEmail {
                email: String,
                primary: bool,
                verified: bool,
            }

            let client = reqwest::Client::new();

            let user: GithubUser = client
                .get("https://api.github.com/user")
                .header("Authorization", format!("Bearer {}", access_token))
                .header("User-Agent", "SSO-Service")
                .send()
                .await
                .map_err(|e| AppError::OAuth(format!("Failed to fetch user: {}", e)))?
                .json()
                .await
                .map_err(|e| AppError::OAuth(format!("Failed to parse user: {}", e)))?;

            let email = if let Some(email) = user.email {
                email
            } else {
                let emails: Vec<GithubEmail> = client
                    .get("https://api.github.com/user/emails")
                    .header("Authorization", format!("Bearer {}", access_token))
                    .header("User-Agent", "SSO-Service")
                    .send()
                    .await
                    .map_err(|e| AppError::OAuth(format!("Failed to fetch emails: {}", e)))?
                    .json()
                    .await
                    .map_err(|e| AppError::OAuth(format!("Failed to parse emails: {}", e)))?;

                emails
                    .into_iter()
                    .find(|e| e.primary && e.verified)
                    .map(|e| e.email)
                    .ok_or_else(|| AppError::OAuth("No verified email found".to_string()))?
            };

            Ok(crate::auth::sso::UserInfo {
                provider_user_id: user.id.to_string(),
                email,
                name: user.name,
            })
        }
        Provider::Google => {
            #[derive(Deserialize)]
            struct GoogleUser {
                id: String,
                email: String,
                name: Option<String>,
            }

            let client = reqwest::Client::new();
            let user: GoogleUser = client
                .get("https://www.googleapis.com/oauth2/v2/userinfo")
                .header("Authorization", format!("Bearer {}", access_token))
                .send()
                .await
                .map_err(|e| AppError::OAuth(format!("Failed to fetch user: {}", e)))?
                .json()
                .await
                .map_err(|e| AppError::OAuth(format!("Failed to parse user: {}", e)))?;

            Ok(crate::auth::sso::UserInfo {
                provider_user_id: user.id,
                email: user.email,
                name: user.name,
            })
        }
        Provider::Microsoft => {
            #[derive(Deserialize)]
            struct MicrosoftUser {
                id: String,
                #[serde(rename = "userPrincipalName")]
                email: String,
                #[serde(rename = "displayName")]
                name: Option<String>,
            }

            let client = reqwest::Client::new();
            let user: MicrosoftUser = client
                .get("https://graph.microsoft.com/v1.0/me")
                .header("Authorization", format!("Bearer {}", access_token))
                .send()
                .await
                .map_err(|e| AppError::OAuth(format!("Failed to fetch user: {}", e)))?
                .json()
                .await
                .map_err(|e| AppError::OAuth(format!("Failed to parse user: {}", e)))?;

            Ok(crate::auth::sso::UserInfo {
                provider_user_id: user.id,
                email: user.email,
                name: user.name,
            })
        }
    }
}

/// Record login event for analytics
async fn record_login_event(
    pool: &SqlitePool,
    user_id: &str,
    service_id: &str,
    provider: Provider,
) -> Result<()> {
    let id = Uuid::new_v4().to_string();
    let provider_str = provider.as_str();

    // Record login event (fire and forget - don't fail the login if this fails)
    let _ = sqlx::query(
        "INSERT INTO login_events (id, user_id, service_id, provider, created_at)
         VALUES (?, ?, ?, ?, datetime('now'))"
    )
    .bind(&id)
    .bind(user_id)
    .bind(service_id)
    .bind(provider_str)
    .execute(pool)
    .await;

    Ok(())
}
